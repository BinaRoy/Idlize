# idlinter architecture and extensions

## CLI for users

At first, user runs `idlinter` with values for `--check <paths...>`, `--load <paths...>` and `--features <features...>`. The reason to separate `--load` from `--check` is to avoid unnecessary diagnostics for files that supposed to be only loaded as dependencies. While diagnostics themselves are usually quick, reports can be quite long, and using only subset in `--check` provides better UX for checking and demonstration. And some name-related or type-related checks are only necessary for specific IDL processing pipelines, `--features` allows to enable them.

`idlinter` sets up requested features and starts loading files from `--check` and `--load` one by one. Any parsing error becomes `fatal` for specific file, but the rest will parsed and processed.

When all files are loaded - validation starts. Only global passes (registered without features) or passes under enabled features are activated, along with their dependencies.

After validation stops - pretty formatted reports are generated, containing diagnostics and highlighted locations. Summary, containing total numbers of different kinds of diagnostics, is always printed at the end.

```
error[E200]: Unresolved reference
    --> es2panda_lib.idl:3595:52
     |
3595 | [Entity=Class, nameaspace=ir] interface Annotated: T {
     |                                                    ^ Unresolved reference
     = Unresolved reference

error[E200]: Unresolved reference
    --> es2panda_lib.idl:3601:48
     |
3601 | [Entity=Class, nameaspace=ir] interface Typed: T {
     |                                                ^ Unresolved reference
     = Unresolved reference

error[E200]: Unresolved reference
    --> es2panda_lib.idl:4277:60
     |
4277 | [Entity=Class, nameaspace=ir] interface AnnotationAllowed: T {
     |                                                            ^ Unresolved reference
     = Unresolved reference

fatal: 0, error: 3, warning: 0, information: 0, hint: 0
```

`idlinter` has exit codes: (1) for invalid arguments/paths and (2) in case of errors or fatals found in .idl files. That allows easier integration into automatic pipelines.

## Internal API for developers

### Entry

`idlinterMain()` in `src/cli.ts` translates user's CLI request into series of API calls and uses `idlManager` (global instance of `IdlProcessingManager`) for validation.

It activates features mentioned in `--features` option, scans files/directories in `--check` and `--load` and adds files to `idlManager`, where they are parsed and transformed to a tree of `IDLNode` instances. If something wrong on options level - exit code (1) is returned.

Then validation processing happens (`idlManager.runPasses()`), collected diagnostics are formatted and printed along with totals (`outputReadableResult()` from `src/formatter.ts`), and appropriate exit code (0 or 2) is generated.

### Parsing

`idlinter` uses existing `@idlizer/core` and `webidl2` facililies for parsing and `IDLNode` tree creation. Sadly, `webidl2` parsing metadata is not suitable for diagnostics, so `src/parser.ts` stores additional resources in `Parsed` instance, adds it as `._parsed` to every `IDLNode` in processing and does the best to restore actual locations from pieces of metadata generated by `webidl2`.

Any time location is required family of location-related functions in `src/parser.ts`, starting with `locationForNode()` (or `locationsFromAuto()` helper), is used.

Supporting proper locations is a good candidate for inclusion into `@idlizer/core` as optional `IDLNode` fields (full restoration takes unnoticeable amount of time even on a large SDK with hundreds of .idl files). Also, if in the future `@idlizer/core` switches to a better parser they can be provided naturally (not restored from `webidl2` metadata).

### Features and passes

Validator architecture (especially for validator that can be used with multiple pipelines having different requirements) is quite different from compiler architecture. Instead of a fixed sequence of evaluation and transformation passes (some of which can appear multiple times after other transformations) we need to collect and check information in a flexible DAG of passes, without inplace transformations affecting independent checks. So effort was made to provide such flexibility and make creation of new passes as non-intrusive as possible.

System of passes (and features that do allow to organize them and enable by demand) is the core of `idlinter`.

Each feature or pass has fully qualified identifier with dots separating identifier segments (number of segments is currently not limited). For example:

`globalPass1`, `globalPass2` - global passes that are always active.

`someFeature`, `someFeature.subFeature`, `someFeature.subFeature.subSubFeature` - features, activation of a feature activates all passes and features in it.

`someFeature.pass1`, `someFeature.subFeature.pass2` - local passes that are active only if parent ancestor feature is active (OR other active pass has such pass as a dependency).

`.hiddenPass1`, `.hiddenPass2` - hidden passes with names starting with dot, they are active ONLY if other active pass has such pass as a dependency.

You can see how features and passes are created in `src/validator.ts`.

By calling `idlManager.newFeature("someFeature", "Feature description...")` developer registers new feature, that will be available in `--features` and displayed in CLI help message.

Then `idlManager.newFeature("someFeature.subfeature", "Subfeature description...")` allows to register subfeature, if needed (also will be available in `--features`).

And `const myPass = idlManager.newPass("myPass", dependencies, stateMaker)` creates global pass (local and hidden passes are differ only by name). Then pass is populated by rules in form of patterns (only IDL nodes with fields having listed values are affecting by rule) and `before`/`after` assignments of actual processing handlers. Each node in currently loaded files (starting from `IDLFile` nodes) is visited twice in depth-first manner.

### Practical pass creation example

Let's see how `enumPass` in `src/validator.ts` is created:

Pass creation. This `enumPass` has no dependencies, so dependencies list is empty. `stateMaker` returns object with `enums` field. It will be used as state for collecting information during the whole pass. Also, TypeScript will take care of propagating the type of this state to `st` arguments of all processing handlers for `enumPass`.

```typescript
const enumPass = idlManager.newPass("enumPass", [], () => ({enums: new Map<idl.IDLNode, IdlNodeAny[]>()}))
```

First rule. It contains pattern (see `IdlNodePattern` in `src/idltype.ts`), and processing handler assigned for "`before` this node" position while walking the tree. Processing handler takes `node` (of type `IdlNodeAny` from `src/idltype.ts`) and `st` (of type of value returned by stateMaker for `enumPass`).

Here it just binds empty array in `st.enums` to current `enum` node.

```typescript
enumPass.on({kind: idl.IDLKind.Enum}).before = (node, st) => st.enums.set(node, [])
```

Second rule. Array created in previous rule is populated by nodes having different initializer types. Both `before` or `after` can be used for such rule.

```typescript
enumPass.on({kind: idl.IDLKind.EnumMember}).after = (node, st) => {
    let nodes = st.enums.get(node.parent!)!
    if (nodes.length == 0 || nodes.length == 1 && typeof nodes[0].initializer != typeof node.initializer) {
        nodes.push(node)
    }
}
```

Third rule. We are visiting `enum` second time after all members in it was processed. Using `after` is crucial here. If we have at least two nodes with different initializer types - report diagnostic message of kind `InconsistentEnum`.

```typescript
enumPass.on({kind: idl.IDLKind.Enum}).after = (node, st) => {
    let nodes = st.enums.get(node)!
    if (nodes.length == 2) {
        InconsistentEnum.reportDiagnosticMessage([locationForNode(node, "name"), nodes[0], nodes[1]])
    }
}
```

So, that minimal amount of code, consisting of pass creation and three rules, allows independently checking enums consistency, and does not require any complex registrations. It exists - then it works (if global, activated by features or activated by dependencies).

And if you need information from other passes - list them as `dependencies` when creating yours, and use their states (as `somePass.state`) in your `stateMaker`.

As a final step, while any initial preparations can be performed in `stateMaker`, some information can be computed only after walking all nodes in some pass. There is `afterAll` handler for this. See it in `locationCheckPass` example in the same `src/validator.ts`:

```typescript
locationCheckPass.afterAll = (st) => {
    console.log(`Stats: ${st[1]}/${st[0]} nodes have locations`);
}
```

### Reporting diagnostics

Diagnostic-related types (with `DiagnosticMessage` being the main one) are declared and well documented in `src/diagnostictypes.ts`. They are designed to allow further processing, and can be easily converted in LSP format if needed.

`src/messages.ts` contains templating for them (`DiagnosticMessageKind`), and already declared templates like `ParsingError`. If you don't have matching instance of `DiagnosticMessageKind` for your validation pass - create the new one there.

When all passes are finished - `outputReadableResult(idlManager.results)` is called and simple but powerfull formatting routines in `src/formatting.ts` are taking place. Messages are printed along with automatically counted `totals`.

Diagnostics and formatting are also universal (can be used in other tools output) and good candidates for inclusion into `@idlizer/core`, the whole IDLize suite can significantly benefit from it.
