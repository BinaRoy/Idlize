## 5. 枚举与选项类实施设计 v1.1

### 📋 修改说明

**🔍 问题分析：**
当前 `dts2peer` 工具在枚举和选项类的处理方面存在不足：
- TypeScript 的字面量联合类型没有转换为 Cangjie 枚举，而是生成复杂的联合类
- 缺乏标准化的枚举注解和格式规范
- 接口的可选属性组合没有提取为便利的选项类（Options 模式）
- 生成的代码不符合 Cangjie 的枚举最佳实践

**仓颉语言特有问题：**
- 没有充分利用仓颉语言的 `@Derive[Equatable]` 注解系统
- 枚举值命名不符合仓颉语言的 PascalCase 规范
- 选项类没有使用仓颉语言的链式调用模式
- 缺乏对仓颉语言特有类型（如 `ResourceStr`、`Length`、`ResourceColor`）的支持

**🎯 优化策略：**
1. **字面量枚举识别**：自动识别 TypeScript 字面量联合类型并转换为 Cangjie 枚举
2. **枚举标准化**：应用标准的 Cangjie 枚举注解（`@Derive[Equatable]`、`@!APILevel`）
3. **选项类生成**：为复杂接口自动生成对应的 Options 类，简化 API 使用
4. **枚举值映射**：建立 TypeScript 字面量到 Cangjie 枚举值的智能映射规则

**🎯 最终目标：**
- 提供更符合 Cangjie 语言习惯的枚举定义
- 减少联合类的使用，改善类型系统的清晰度
- 为复杂 API 提供更便利的选项类模式
- 确保生成的枚举代码符合官方规范和最佳实践
- 充分利用仓颉语言的类型系统和语法特性

### 📋 转换用例示例

<details>
<summary>点击查看完整的转换用例</summary>

#### 用例 1: 字面量联合类型转枚举（基于仓颉语言枚举类型系统）

**🔍 问题分析：**
TypeScript 的字面量联合类型被转换为复杂的 `Union_*` 类，导致代码可读性差、类型安全性低，且不符合仓颉语言的枚举最佳实践。

**TypeScript 输入:**
```typescript
// 字面量联合类型定义
interface TextProps {
  // 文本对齐方式
  textAlign?: 'left' | 'center' | 'right' | 'justify';
  
  // 字体粗细
  fontWeight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';
  
  // 字体样式
  fontStyle?: 'normal' | 'italic' | 'oblique';
  
  // 文本装饰
  textDecoration?: 'none' | 'underline' | 'line-through' | 'overline';
  
  // 文本大小写
  textCase?: 'none' | 'uppercase' | 'lowercase' | 'capitalize';
}

interface ButtonProps {
  // 按钮类型
  type?: 'capsule' | 'circle' | 'normal';
  
  // 按钮状态
  stateEffect?: boolean;
  
  // 按钮大小
  size?: 'small' | 'medium' | 'large';
}
```

**❌ 当前生成的 Cangjie 代码（问题版本）：**
```cangjie
public class TextProps {
  // 字面量联合类型生成复杂的 Union_* 类
  public var textAlign: Option<Union_Left_Center_Right_Justify> = None  // 复杂的联合类型
  public var fontWeight: Option<Union_Normal_Bold_100_200_300_400_500_600_700_800_900> = None  // 复杂的联合类型
  public var fontStyle: Option<Union_Normal_Italic_Oblique> = None  // 复杂的联合类型
  public var textDecoration: Option<Union_None_Underline_LineThrough_Overline> = None  // 复杂的联合类型
  public var textCase: Option<Union_None_Uppercase_Lowercase_Capitalize> = None  // 复杂的联合类型
}

public class ButtonProps {
  // 字面量联合类型生成复杂的 Union_* 类
  public var type: Option<Union_Capsule_Circle_Normal> = None  // 复杂的联合类型
  public var stateEffect: Bool = false
  public var size: Option<Union_Small_Medium_Large> = None  // 复杂的联合类型
}

// 生成的复杂 Union_* 类
public class Union_Left_Center_Right_Justify {
  // 复杂的联合类型实现
}

public class Union_Normal_Bold_100_200_300_400_500_600_700_800_900 {
  // 复杂的联合类型实现
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言枚举类型系统/实际使用）：**
```cangjie
// 自动生成的枚举类型（基于仓颉语言枚举类型系统）
@Derive[Equatable]
@!APILevel[12]
public enum TextAlign {
  Left,
  Center,
  Right,
  Justify
}

@Derive[Equatable]
@!APILevel[12]
public enum FontWeight {
  Normal,
  Bold,
  Weight100,
  Weight200,
  Weight300,
  Weight400,
  Weight500,
  Weight600,
  Weight700,
  Weight800,
  Weight900
}

@Derive[Equatable]
@!APILevel[12]
public enum FontStyle {
  Normal,
  Italic,
  Oblique
}

@Derive[Equatable]
@!APILevel[12]
public enum TextDecoration {
  None,
  Underline,
  LineThrough,
  Overline
}

@Derive[Equatable]
@!APILevel[12]
public enum TextCase {
  None,
  Uppercase,
  Lowercase,
  Capitalize
}

@Derive[Equatable]
@!APILevel[12]
public enum ButtonType {
  Capsule,
  Circle,
  Normal
}

@Derive[Equatable]
@!APILevel[12]
public enum ComponentSize {
  Small,
  Medium,
  Large
}

// 使用枚举的接口定义（基于仓颉语言类型系统）
public interface TextProps {
  textAlign!: TextAlign = TextAlign.Left;  // 使用枚举类型
  fontWeight!: FontWeight = FontWeight.Normal;  // 使用枚举类型
  fontStyle!: FontStyle = FontStyle.Normal;  // 使用枚举类型
  textDecoration!: TextDecoration = TextDecoration.None;  // 使用枚举类型
  textCase!: TextCase = TextCase.None;  // 使用枚举类型
}

public interface ButtonProps {
  type!: ButtonType = ButtonType.Normal;  // 使用枚举类型
  stateEffect!: Bool = true;
  size!: ComponentSize = ComponentSize.Medium;  // 使用枚举类型
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的 `@Derive[Equatable]` 注解，提供类型安全的比较操作
- ✅ 遵循仓颉语言的 PascalCase 枚举值命名规范
- ✅ 使用仓颉语言的 `@!APILevel[12]` 注解，确保 API 兼容性
- ✅ 提供语义化的枚举类型，提高代码可读性和类型安全性
- ✅ 减少复杂的 `Union_*` 类，简化类型系统结构

#### 用例 2: 选项类生成（基于仓颉语言类型系统和链式调用模式）

**🔍 问题分析：**
复杂的组件配置接口使用 `Option<T>` 类型，导致 API 使用繁琐，缺乏便利的链式调用模式，不符合仓颉语言的最佳实践。

**TypeScript 输入:**
```typescript
// 复杂的组件配置接口
interface DialogConfig {
  // 基础属性
  title?: string;
  content?: string;
  visible?: boolean;
  
  // 样式属性
  width?: number | string;
  height?: number | string;
  backgroundColor?: string;
  borderRadius?: number;
  
  // 行为属性
  closable?: boolean;
  maskClosable?: boolean;
  showCancel?: boolean;
  showConfirm?: boolean;
  
  // 回调函数
  onConfirm?: () => void;
  onCancel?: () => void;
  onClose?: () => void;
}

// 使用配置的组件
interface DialogProps {
  config?: DialogConfig;
  children?: ReactNode;
}
```

**❌ 当前生成的 Cangjie 代码（问题版本）：**
```cangjie
public interface DialogConfig {
  // 所有属性都是可选的，使用 Option 类型
  title?: Option<String>;
  content?: Option<String>;
  visible?: Option<Bool>;
  width?: Option<Union_Number_String>;
  height?: Option<Union_Number_String>;
  backgroundColor?: Option<String>;
  borderRadius?: Option<Int64>;
  closable?: Option<Bool>;
  maskClosable?: Option<Bool>;
  showCancel?: Option<Bool>;
  showConfirm?: Option<Bool>;
  onConfirm?: Option<Callback_Void_Void>;
  onCancel?: Option<Callback_Void_Void>;
  onClose?: Option<Callback_Void_Void>;
}

public interface DialogProps {
  config?: Option<DialogConfig>;
  children?: Option<ReactNode>;
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言类型系统/链式调用模式）：**
```cangjie
// 自动生成的选项类（基于仓颉语言类型系统和链式调用模式）
@Derive[Equatable]
@!APILevel[12]
public class DialogOptions {
  // 基础属性（使用仓颉语言语义化类型）
  public var title: ResourceStr = ""
  public var content: ResourceStr = ""
  public var visible: Bool = false
  
  // 样式属性（使用仓颉语言 Length 和 ResourceColor 类型）
  public var width: Length = 300.vp
  public var height: Length = Length.Auto
  public var backgroundColor: ResourceColor = Color.White
  public var borderRadius: Length = 8.vp
  
  // 行为属性（使用仓颉语言 Bool 类型）
  public var closable: Bool = true
  public var maskClosable: Bool = true
  public var showCancel: Bool = true
  public var showConfirm: Bool = true
  
  // 回调函数（使用仓颉语言 Option<T> 类型系统）
  public var onConfirm: Option<() -> Unit> = None
  public var onCancel: Option<() -> Unit> = None
  public var onClose: Option<() -> Unit> = None
  
  // 便利构造方法（支持仓颉语言链式调用）
  public func setTitle(value: ResourceStr): DialogOptions {
    this.title = value
    return this
  }
  
  public func setContent(value: ResourceStr): DialogOptions {
    this.content = value
    return this
  }
  
  public func setVisible(value: Bool): DialogOptions {
    this.visible = value
    return this
  }
  
  public func setWidth(value: Length): DialogOptions {
    this.width = value
    return this
  }
  
  public func setHeight(value: Length): DialogOptions {
    this.height = value
    return this
  }
  
  public func setBackgroundColor(value: ResourceColor): DialogOptions {
    this.backgroundColor = value
    return this
  }
  
  public func setBorderRadius(value: Length): DialogOptions {
    this.borderRadius = value
    return this
  }
  
  public func setClosable(value: Bool): DialogOptions {
    this.closable = value
    return this
  }
  
  public func setMaskClosable(value: Bool): DialogOptions {
    this.maskClosable = value
    return this
  }
  
  public func setShowCancel(value: Bool): DialogOptions {
    this.showCancel = value
    return this
  }
  
  public func setShowConfirm(value: Bool): DialogOptions {
    this.showConfirm = value
    return this
  }
  
  public func setOnConfirm(callback: () -> Unit): DialogOptions {
    this.onConfirm = Some(callback)
    return this
  }
  
  public func setOnCancel(callback: () -> Unit): DialogOptions {
    this.onCancel = Some(callback)
    return this
  }
  
  public func setOnClose(callback: () -> Unit): DialogOptions {
    this.onClose = Some(callback)
    return this
  }
}

// 使用选项类的组件接口（基于仓颉语言类型系统）
public interface DialogProps {
  config!: DialogOptions = DialogOptions()
  children!: Option<ReactNode> = None
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的语义化类型（`ResourceStr`、`Length`、`ResourceColor`）
- ✅ 支持仓颉语言的链式调用模式，提高 API 便利性
- ✅ 使用仓颉语言的 `Option<T>` 类型系统处理可选回调
- ✅ 提供类型安全的默认值，减少运行时错误
- ✅ 遵循仓颉语言的类定义规范和注解系统

#### 用例 3: 枚举值智能映射（基于仓颉语言命名规范和类型系统）

**🔍 问题分析：**
TypeScript 字面量包含特殊字符、数字和连字符，需要智能映射为符合仓颉语言 PascalCase 命名规范的枚举值，同时保持语义的准确性。

**TypeScript 输入:**
```typescript
// 包含特殊字符和数字的枚举
interface StyleProps {
  // 包含特殊字符的枚举
  position?: 'static' | 'relative' | 'absolute' | 'fixed' | 'sticky';
  
  // 包含数字的枚举
  zIndex?: 0 | 1 | 2 | 3 | 4 | 5 | 10 | 20 | 30 | 50 | 100;
  
  // 包含连字符的枚举
  textTransform?: 'none' | 'capitalize' | 'uppercase' | 'lowercase' | 'full-width';
  
  // 包含下划线的枚举
  fontVariant?: 'normal' | 'small_caps' | 'all_small_caps' | 'petite_caps' | 'all_petite_caps';
  
  // 混合命名风格
  flexDirection?: 'row' | 'row-reverse' | 'column' | 'column-reverse';
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言命名规范/类型系统）：**
```cangjie
// 智能映射的枚举类型（基于仓颉语言命名规范和类型系统）
@Derive[Equatable]
@!APILevel[12]
public enum Position {
  Static,
  Relative,
  Absolute,
  Fixed,
  Sticky
}

@Derive[Equatable]
@!APILevel[12]
public enum ZIndex {
  Zero,      // 0 -> Zero
  One,       // 1 -> One
  Two,       // 2 -> Two
  Three,     // 3 -> Three
  Four,      // 4 -> Four
  Five,      // 5 -> Five
  Ten,       // 10 -> Ten
  Twenty,    // 20 -> Twenty
  Thirty,    // 30 -> Thirty
  Fifty,     // 50 -> Fifty
  Hundred    // 100 -> Hundred
}

@Derive[Equatable]
@!APILevel[12]
public enum TextTransform {
  None,
  Capitalize,
  Uppercase,
  Lowercase,
  FullWidth  // full-width -> FullWidth
}

@Derive[Equatable]
@!APILevel[12]
public enum FontVariant {
  Normal,
  SmallCaps,      // small_caps -> SmallCaps
  AllSmallCaps,   // all_small_caps -> AllSmallCaps
  PetiteCaps,     // petite_caps -> PetiteCaps
  AllPetiteCaps   // all_petite_caps -> AllPetiteCaps
}

@Derive[Equatable]
@!APILevel[12]
public enum FlexDirection {
  Row,
  RowReverse,     // row-reverse -> RowReverse
  Column,
  ColumnReverse   // column-reverse -> ColumnReverse
}

// 使用智能映射枚举的接口（基于仓颉语言类型系统）
public interface StyleProps {
  position!: Position = Position.Static;
  zIndex!: ZIndex = ZIndex.Zero;
  textTransform!: TextTransform = TextTransform.None;
  fontVariant!: FontVariant = FontVariant.Normal;
  flexDirection!: FlexDirection = FlexDirection.Row;
}
```

**🎯 优化效果：**
- ✅ 遵循仓颉语言的 PascalCase 命名规范
- ✅ 智能处理数字、连字符和下划线的映射
- ✅ 使用仓颉语言的 `@Derive[Equatable]` 注解提供类型安全
- ✅ 保持语义的准确性和可读性
- ✅ 提供类型安全的默认值

#### 用例 4: 复杂枚举组合（基于仓颉语言类型系统和选项类模式）

**🔍 问题分析：**
复杂的嵌套对象和数组中的枚举类型需要扁平化处理，并生成对应的选项类，以符合仓颉语言的类型系统和最佳实践。

**TypeScript 输入:**
```typescript
// 复杂的枚举组合场景
interface ComplexEnumProps {
  // 嵌套对象中的枚举
  layout?: {
    direction?: 'horizontal' | 'vertical';
    alignment?: 'start' | 'center' | 'end' | 'space-between' | 'space-around';
    wrap?: 'nowrap' | 'wrap' | 'wrap-reverse';
  };
  
  // 数组中的枚举
  animations?: ('fade' | 'slide' | 'scale' | 'rotate')[];
  
  // 条件枚举
  theme?: 'light' | 'dark' | 'auto';
  
  // 状态枚举
  status?: 'idle' | 'loading' | 'success' | 'error' | 'disabled';
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言类型系统/选项类模式）：**
```cangjie
// 自动生成的枚举类型（基于仓颉语言枚举类型系统）
@Derive[Equatable]
@!APILevel[12]
public enum LayoutDirection {
  Horizontal,
  Vertical
}

@Derive[Equatable]
@!APILevel[12]
public enum LayoutAlignment {
  Start,
  Center,
  End,
  SpaceBetween,
  SpaceAround
}

@Derive[Equatable]
@!APILevel[12]
public enum LayoutWrap {
  Nowrap,
  Wrap,
  WrapReverse
}

@Derive[Equatable]
@!APILevel[12]
public enum AnimationType {
  Fade,
  Slide,
  Scale,
  Rotate
}

@Derive[Equatable]
@!APILevel[12]
public enum ThemeType {
  Light,
  Dark,
  Auto
}

@Derive[Equatable]
@!APILevel[12]
public enum ComponentStatus {
  Idle,
  Loading,
  Success,
  Error,
  Disabled
}

// 布局选项类（基于仓颉语言选项类模式和链式调用）
@Derive[Equatable]
@!APILevel[12]
public class LayoutOptions {
  public var direction: LayoutDirection = LayoutDirection.Horizontal
  public var alignment: LayoutAlignment = LayoutAlignment.Start
  public var wrap: LayoutWrap = LayoutWrap.Nowrap
  
  public func setDirection(value: LayoutDirection): LayoutOptions {
    this.direction = value
    return this
  }
  
  public func setAlignment(value: LayoutAlignment): LayoutOptions {
    this.alignment = value
    return this
  }
  
  public func setWrap(value: LayoutWrap): LayoutOptions {
    this.wrap = value
    return this
  }
}

// 使用枚举的接口定义（基于仓颉语言类型系统）
public interface ComplexEnumProps {
  layout!: LayoutOptions = LayoutOptions();
  animations!: Option<ArrayList<AnimationType>> = None;  // 使用仓颉语言 ArrayList 和 Option 类型
  theme!: ThemeType = ThemeType.Light;
  status!: ComponentStatus = ComponentStatus.Idle;
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的枚举类型系统，提供类型安全
- ✅ 扁平化复杂嵌套结构，简化类型定义
- ✅ 使用仓颉语言的选项类模式，提供便利的 API
- ✅ 支持仓颉语言的链式调用模式
- ✅ 使用仓颉语言的 `ArrayList` 和 `Option<T>` 类型系统

**转换效果对比:**

| 枚举场景 | TypeScript | 当前生成 | 改进后生成 | 说明 | 改进效果 |
|----------|------------|----------|------------|------|----------|
| **字面量联合** | `'a' \| 'b' \| 'c'` | `Union_A_B_C` | `EnumType` | 基于仓颉语言枚举类型系统 | ✅ 语义化 |
| **数字枚举** | `0 \| 1 \| 2` | `Union_0_1_2` | `EnumType` | 遵循仓颉语言 PascalCase 规范 | ✅ 可读性 |
| **特殊字符** | `'a-b' \| 'c_d'` | `Union_A_B_C_D` | `EnumType` | 智能映射为仓颉语言命名规范 | ✅ 智能映射 |
| **选项类** | 复杂接口 | `Option<T>` | `OptionsClass` | 使用仓颉语言链式调用模式 | ✅ 便利性 |
| **嵌套枚举** | 对象嵌套 | 复杂 Union_* | 扁平化枚举 | 基于仓颉语言类型系统 | ✅ 简化结构 |

**性能改进统计:**

| 指标 | 改进前 | 改进后 | 说明 | 改进幅度 |
|------|--------|--------|------|----------|
| **枚举类型数量** | 0 | 50+ | 基于仓颉语言枚举类型系统 | 新增 100% |
| **Union_* 类数量** | 100+ | 20-30 | 使用仓颉语言语义化类型 | 减少 70%+ |
| **代码可读性** | 差 | 好 | 遵循仓颉语言命名规范 | 显著提升 |
| **类型安全性** | 一般 | 高 | 使用仓颉语言 `@Derive[Equatable]` 注解 | 显著提升 |
| **API 便利性** | 低 | 高 | 支持仓颉语言链式调用模式 | 显著提升 |
| **语义化类型使用** | 无 | 全面 | 使用 `ResourceStr`、`Length`、`ResourceColor` 等 | 100% 覆盖 |

</details>

### 5.1 字面量枚举自动提取（基于仓颉语言枚举类型系统）

**字面量枚举提取器：**

<details>
<summary>点击查看 LiteralEnumExtractor 类实现代码</summary>

```typescript
class LiteralEnumExtractor {
  private enumRegistry = new Map<string, EnumDefinition>();
  private minOccurrences = 2; // 最少出现次数才生成枚举
  
  extractFromUnionType(unionType: ts.UnionTypeNode): EnumExtractionResult | null {
    const literals = this.extractStringLiterals(unionType);
    
    if (literals.length < 2) {
      return null; // 单个字面量不需要枚举
    }
    
    const enumKey = literals.sort().join('|');
    const existingEnum = this.enumRegistry.get(enumKey);
    
    if (existingEnum) {
      existingEnum.occurrences++;
      return {
        enumName: existingEnum.name,
        shouldGenerate: existingEnum.occurrences >= this.minOccurrences
      };
    }
    
    const enumName = this.generateEnumName(literals);
    this.enumRegistry.set(enumKey, {
      name: enumName,
      literals,
      occurrences: 1
    });
    
    return {
      enumName,
      shouldGenerate: false // 等待更多出现
    };
  }
  
  private extractStringLiterals(unionType: ts.UnionTypeNode): string[] {
    return unionType.types
      .filter(ts.isLiteralTypeNode)
      .map(node => {
        if (ts.isStringLiteral(node.literal)) {
          return node.literal.text;
        }
        return null;
      })
      .filter(Boolean);
  }
  
  private generateEnumName(literals: string[]): string {
    // 尝试从字面量推断语义
    const commonPrefixes = this.findCommonPrefixes(literals);
    const commonSuffixes = this.findCommonSuffixes(literals);
    
    if (commonPrefixes.length > 0) {
      return this.capitalize(commonPrefixes[0]) + 'Type';
    }
    
    if (commonSuffixes.length > 0) {
      return this.capitalize(commonSuffixes[0]) + 'Option';
    }
    
    // 基于内容推断
    if (literals.every(l => ['left', 'center', 'right'].includes(l))) {
      return 'HorizontalAlign';
    }
    
    if (literals.every(l => ['top', 'middle', 'bottom'].includes(l))) {
      return 'VerticalAlign';
    }
    
    // 默认命名
    return 'LiteralOption';
  }
  
  generateEnumDefinition(enumDef: EnumDefinition): string {
    const values = enumDef.literals.map(literal => {
      return this.pascalCase(literal);
    }).join('\n    | ');
    
    return `@Derive[Equatable]
@!APILevel[12]
public enum ${enumDef.name} {
    ${values}
}`;
  }
  
  generateOptimizationReport(): EnumOptimizationReport {
    const recommended = Array.from(this.enumRegistry.values())
      .filter(def => def.occurrences >= this.minOccurrences);
      
    const potential = Array.from(this.enumRegistry.values())
      .filter(def => def.occurrences < this.minOccurrences);
    
    return {
      recommendedEnums: recommended.length,
      potentialEnums: potential.length,
      estimatedReduction: this.calculateReduction(recommended)
    };
  }
  
  private calculateReduction(enums: EnumDefinition[]): string {
    const originalUnions = enums.reduce((sum, e) => sum + e.occurrences, 0);
    const newEnums = enums.length;
    const reduction = ((originalUnions - newEnums) / originalUnions * 100).toFixed(1);
    
    return `${reduction}% (${originalUnions} unions → ${newEnums} enums)`;
  }
}

interface EnumDefinition {
  name: string;
  literals: string[];
  occurrences: number;
}

interface EnumExtractionResult {
  enumName: string;
  shouldGenerate: boolean;
}

interface EnumOptimizationReport {
  recommendedEnums: number;
  potentialEnums: number;
  estimatedReduction: string;
}
```

</details>

### 5.2 选项类生成优化（基于仓颉语言类型系统和链式调用模式）

**选项类生成器：**

<details>
<summary>点击查看 OptionsClassGenerator 类实现代码</summary>

```typescript
/**
 * 选项类生成器（基于仓颉语言类型系统和链式调用模式）
 * 为复杂接口自动生成对应的 Options 类，提供便利的链式调用 API
 */
class OptionsClassGenerator {
  // 仓颉语言语义化类型映射表
  private semanticTypeMap = new Map<string, string>([
    ['string', 'ResourceStr'],
    ['number', 'Float64'],
    ['boolean', 'Bool'],
    ['int', 'Int64'],
    ['float', 'Float64'],
    ['color', 'ResourceColor'],
    ['length', 'Length'],
    ['duration', 'Duration'],
    ['callback', 'Option<() -> Unit>'],
    ['array', 'ArrayList<T>']
  ]);
  
  /**
   * 生成选项类（基于仓颉语言类型系统）
   * @param componentName 组件名称
   * @param properties 属性定义数组
   * @returns 生成的选项类代码
   */
  generateOptionsClass(
    componentName: string,
    properties: PropertyDefinition[]
  ): string {
    const className = `${componentName}Options`;
    
    // 生成属性声明（基于仓颉语言类型系统）
    const propertyDeclarations = properties.map(prop => 
      this.generatePropertyDeclaration(prop)
    ).join('\n    ');
    
    // 生成便利构造方法（基于仓颉语言链式调用模式）
    const builderMethods = this.generateBuilderMethods(componentName, properties);
    
    // 生成选项类（基于仓颉语言类定义规范）
    return `@Derive[Equatable]
@!APILevel[12]
public class ${className} {
    ${propertyDeclarations}
    
    // 默认构造函数（基于仓颉语言构造函数规范）
    public init() {
        // 使用默认值初始化
    }
    
    ${builderMethods}
}`;
  }
  
  /**
   * 生成属性声明（基于仓颉语言类型系统）
   * @param prop 属性定义
   * @returns 属性声明代码
   */
  private generatePropertyDeclaration(prop: PropertyDefinition): string {
    const cangjieType = this.mapToCangjieType(prop.type);
    const defaultValue = this.generateDefaultValue(prop, cangjieType);
    
    return `public var ${prop.name}!: ${cangjieType} = ${defaultValue}`;
  }
  
  /**
   * 映射到仓颉语言类型（基于仓颉语言类型系统）
   * @param tsType TypeScript 类型
   * @returns 仓颉语言类型
   */
  private mapToCangjieType(tsType: string): string {
    // 检查语义化类型映射
    for (const [pattern, cangjieType] of this.semanticTypeMap) {
      if (tsType.includes(pattern)) {
        return cangjieType;
      }
    }
    
    // 检查是否为枚举类型
    if (tsType.includes('|') && !tsType.includes('Union_')) {
      return this.extractEnumType(tsType);
    }
    
    // 检查是否为回调函数类型
    if (tsType.includes('=>') || tsType.includes('Callback')) {
      return 'Option<() -> Unit>';
    }
    
    // 默认映射
    const typeMap: Record<string, string> = {
      'string': 'ResourceStr',
      'number': 'Float64',
      'boolean': 'Bool',
      'int': 'Int64',
      'float': 'Float64',
      'any': 'Any',
      'void': 'Unit',
      'null': 'Unit',
      'undefined': 'Unit'
    };
    
    return typeMap[tsType] || 'Any';
  }
  
  /**
   * 生成默认值（基于仓颉语言类型系统）
   * @param prop 属性定义
   * @param cangjieType 仓颉语言类型
   * @returns 默认值代码
   */
  private generateDefaultValue(prop: PropertyDefinition, cangjieType: string): string {
    // 基于仓颉语言类型系统生成默认值
    const defaultValueMap: Record<string, string> = {
      'ResourceStr': '""',
      'ResourceColor': 'Color.Transparent',
      'Length': 'Length.Auto',
      'Float64': '0.0',
      'Int64': '0',
      'Bool': 'false',
      'Duration': 'Duration.of(0)',
      'Option<() -> Unit>': 'None',
      'ArrayList<T>': 'ArrayList<T>()'
    };
    
    // 检查是否有自定义默认值
    if (prop.defaultValue) {
      return this.convertToCangjieValue(prop.defaultValue, cangjieType);
    }
    
    // 使用类型默认值
    return defaultValueMap[cangjieType] || 'null';
  }
  
  /**
   * 转换为仓颉语言值（基于仓颉语言语法规范）
   * @param value 原始值
   * @param cangjieType 仓颉语言类型
   * @returns 转换后的值
   */
  private convertToCangjieValue(value: string, cangjieType: string): string {
    switch (cangjieType) {
      case 'ResourceStr':
        return `"${value}"`;
      case 'ResourceColor':
        return `Color.${this.capitalize(value)}`;
      case 'Length':
        return `${value}.vp`;
      case 'Float64':
        return `${value}.0`;
      case 'Int64':
        return value;
      case 'Bool':
        return value.toLowerCase();
      case 'Duration':
        return `Duration.of(${value})`;
      default:
        return value;
    }
  }
  
  /**
   * 提取枚举类型（基于仓颉语言枚举类型系统）
   * @param unionType 联合类型字符串
   * @returns 枚举类型名称
   */
  private extractEnumType(unionType: string): string {
    // 从联合类型中提取枚举名称
    const literals = unionType.split('|').map(s => s.trim().replace(/['"]/g, ''));
    const enumName = this.generateEnumName(literals);
    return enumName;
  }
  
  /**
   * 生成枚举名称（基于仓颉语言命名规范）
   * @param literals 字面量数组
   * @returns 枚举名称
   */
  private generateEnumName(literals: string[]): string {
    // 基于字面量内容推断枚举名称
    if (literals.every(l => ['left', 'center', 'right'].includes(l))) {
      return 'HorizontalAlign';
    }
    if (literals.every(l => ['top', 'middle', 'bottom'].includes(l))) {
      return 'VerticalAlign';
    }
    if (literals.every(l => ['small', 'medium', 'large'].includes(l))) {
      return 'ComponentSize';
    }
    if (literals.every(l => ['light', 'dark', 'auto'].includes(l))) {
      return 'ThemeType';
    }
    
    // 默认命名
    return 'CustomEnum';
  }
  
  /**
   * 生成便利构造方法（基于仓颉语言链式调用模式）
   * @param componentName 组件名称
   * @param properties 属性定义数组
   * @returns 便利构造方法代码
   */
  private generateBuilderMethods(
    componentName: string, 
    properties: PropertyDefinition[]
  ): string {
    return properties.map(prop => {
      const methodName = `set${this.capitalize(prop.name)}`;
      const cangjieType = this.mapToCangjieType(prop.type);
      
      return `  /**
   * 设置 ${prop.name} 属性（基于仓颉语言链式调用模式）
   * @param value ${prop.name} 的值
   * @returns 当前选项类实例，支持链式调用
   */
  public func ${methodName}(value: ${cangjieType}): ${componentName}Options {
    this.${prop.name} = value
    return this
  }`;
    }).join('\n\n');
  }
  
  /**
   * 首字母大写（基于仓颉语言命名规范）
   * @param str 输入字符串
   * @returns 首字母大写的字符串
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  
  /**
   * 生成优化报告（基于仓颉语言类型系统）
   * @param properties 属性定义数组
   * @returns 优化报告
   */
  generateOptimizationReport(properties: PropertyDefinition[]): OptionsOptimizationReport {
    const semanticTypes = properties.filter(prop => 
      this.semanticTypeMap.has(this.mapToCangjieType(prop.type))
    ).length;
    
    const enumTypes = properties.filter(prop => 
      prop.type.includes('|') && !prop.type.includes('Union_')
    ).length;
    
    const callbackTypes = properties.filter(prop => 
      prop.type.includes('=>') || prop.type.includes('Callback')
    ).length;
    
    return {
      totalProperties: properties.length,
      semanticTypes,
      enumTypes,
      callbackTypes,
      estimatedReadability: this.calculateReadability(properties)
    };
  }
  
  /**
   * 计算可读性评分（基于仓颉语言最佳实践）
   * @param properties 属性定义数组
   * @returns 可读性评分
   */
  private calculateReadability(properties: PropertyDefinition[]): string {
    const semanticRatio = properties.filter(prop => 
      this.semanticTypeMap.has(this.mapToCangjieType(prop.type))
    ).length / properties.length;
    
    const enumRatio = properties.filter(prop => 
      prop.type.includes('|') && !prop.type.includes('Union_')
    ).length / properties.length;
    
    const totalScore = (semanticRatio * 0.6 + enumRatio * 0.4) * 100;
    
    if (totalScore >= 80) return '优秀';
    if (totalScore >= 60) return '良好';
    if (totalScore >= 40) return '一般';
    return '需要改进';
  }
}

/**
 * 属性定义接口（基于仓颉语言类型系统）
 */
interface PropertyDefinition {
  name: string;
  type: string;
  hasDefault: boolean;
  defaultValue?: string;
  optional: boolean;
  description?: string;
}

/**
 * 选项类优化报告接口
 */
interface OptionsOptimizationReport {
  totalProperties: number;
  semanticTypes: number;
  enumTypes: number;
  callbackTypes: number;
  estimatedReadability: string;
}
```

</details>

---

## 📋 文档信息

**版本**: v1.1  
**最后更新**: 2024年12月  
**负责人**: dts2peer 开发团队  
**优化重点**: 基于仓颉语言枚举类型系统和选项类模式的优化  
**文档状态**: 完整优化，包含实施指南和最佳实践

## 🎯 主要优化内容

**1. 仓颉语言枚举类型系统深度集成**
- ✅ 使用 `@Derive[Equatable]` 注解，提供类型安全的比较操作
- ✅ 遵循仓颉语言的 PascalCase 枚举值命名规范
- ✅ 使用 `@!APILevel[12]` 注解，确保 API 兼容性
- ✅ 智能映射数字、连字符和下划线为符合规范的枚举值

**2. 选项类模式优化**
- ✅ 使用仓颉语言的语义化类型（`ResourceStr`、`Length`、`ResourceColor`）
- ✅ 支持仓颉语言的链式调用模式，提高 API 便利性
- ✅ 使用仓颉语言的 `Option<T>` 类型系统处理可选回调
- ✅ 提供类型安全的默认值，减少运行时错误

**3. 字面量联合类型智能转换**
- ✅ 自动识别 TypeScript 字面量联合类型并转换为 Cangjie 枚举
- ✅ 基于语义推断合适的枚举名称
- ✅ 减少复杂的 `Union_*` 类，简化类型系统结构
- ✅ 提供语义化的枚举类型，提高代码可读性

**4. 复杂枚举组合处理**
- ✅ 扁平化复杂嵌套结构，简化类型定义
- ✅ 使用仓颉语言的选项类模式，提供便利的 API
- ✅ 支持仓颉语言的 `ArrayList` 和 `Option<T>` 类型系统
- ✅ 智能处理数组和对象中的枚举类型

**5. 枚举值智能映射**
- ✅ 智能处理数字、连字符和下划线的映射
- ✅ 保持语义的准确性和可读性
- ✅ 提供类型安全的默认值
- ✅ 遵循仓颉语言的命名规范和类型系统

## 📊 预期改进效果

| 指标 | 改进前 | 改进后 | 改进幅度 |
|------|--------|--------|----------|
| **枚举类型数量** | 0 | 50+ | 新增 100% |
| **Union_* 类数量** | 100+ | 20-30 | 减少 70%+ |
| **代码可读性** | 差 | 好 | 显著提升 |
| **类型安全性** | 一般 | 高 | 显著提升 |
| **API 便利性** | 低 | 高 | 显著提升 |
| **语义化类型使用** | 无 | 全面 | 100% 覆盖 |
| **链式调用支持** | 无 | 全面 | 100% 覆盖 |

