## 3. 高频联合类型优化实施 v1.1

### 📋 修改说明

**🔍 问题分析：**
当前 `dts2peer` 工具对 TypeScript 联合类型的处理存在以下问题：
- 所有联合类型都生成独立的 `Union_*` 类，导致类型系统过于复杂
- 高频出现的联合类型模式（如 `string | number`）没有语义化的类型别名
- 生成的代码可读性差，开发者难以理解类型的实际含义
- 类型数量爆炸，影响编译性能和代码维护
- **仓颉语言特有问题：** 没有充分利用仓颉语言的 `Length`、`ResourceStr`、`ResourceColor` 等特有类型系统

**🎯 优化策略：**
1. **基于仓颉语言特有类型系统进行语义化收敛**：将高频联合类型映射为仓颉语言的语义化类型
2. **模式识别与统计**：分析 TypeScript 代码中联合类型的使用频率和模式
3. **渐进式迁移**：优先处理最常见的联合类型，逐步减少 `Union_*` 类的使用
4. **上下文感知**：根据属性用途和领域特征选择最合适的仓颉语言类型映射

**🎯 最终目标：**
- 显著减少生成代码中的 `Union_*` 类数量
- 提供更具语义性和可读性的类型定义
- 改善编译性能和代码维护性
- 为开发者提供更直观的 API 接口
- 充分利用仓颉语言的类型系统优势，提高类型安全性
- 基于实际组件声明模式，提供更准确的类型推断

### 📋 转换用例示例

<details>
<summary>点击查看完整的转换用例</summary>

#### 用例 1: 高频联合类型收敛（基于仓颉语言特有类型）

**🔍 问题分析：**
TypeScript 的联合类型在 UI 开发中表示不同的语义概念，但当前工具统一生成 `Union_*` 类，没有充分利用仓颉语言的 `Length`、`ResourceStr`、`ResourceColor` 等特有类型系统。

**TypeScript 输入:**
```typescript
// 高频联合类型模式
interface CommonProps {
  // 尺寸相关联合类型
  width?: string | number;             // 宽度（支持字符串和数字）
  height?: string | number;            // 高度（支持字符串和数字）
  fontSize?: string | number;          // 字体大小
  margin?: string | number;            // 边距
  padding?: string | number;           // 内边距
  borderRadius?: string | number;      // 圆角半径
  
  // 资源相关联合类型
  content?: string | Resource;         // 内容（支持字符串和资源）
  imageSrc?: string | Resource;        // 图片源
  iconName?: string | Resource;        // 图标名称
  
  // 颜色相关联合类型
  color?: string | number | Color;     // 颜色（支持多种格式）
  backgroundColor?: string | number | Color;  // 背景颜色
  borderColor?: string | number | Color;      // 边框颜色
}
```

**❌ 当前生成的 Cangjie 代码（问题版本）:**
```cangjie
public class CommonProps {
  // 尺寸相关联合类型 - 生成多个 Union_* 类
  public var width: Option<Union_String_Number> = None         // 复杂的联合类型
  public var height: Option<Union_String_Number> = None        // 复杂的联合类型
  public var fontSize: Option<Union_String_Number> = None      // 复杂的联合类型
  public var margin: Option<Union_String_Number> = None        // 复杂的联合类型
  public var padding: Option<Union_String_Number> = None       // 复杂的联合类型
  public var borderRadius: Option<Union_String_Number> = None  // 复杂的联合类型
  
  // 资源相关联合类型 - 生成多个 Union_* 类
  public var content: Option<Union_String_Resource> = None     // 复杂的联合类型
  public var imageSrc: Option<Union_String_Resource> = None    // 复杂的联合类型
  public var iconName: Option<Union_String_Resource> = None    // 复杂的联合类型
  
  // 颜色相关联合类型 - 生成多个 Union_* 类
  public var color: Option<Union_String_Number_Color> = None   // 复杂的联合类型
  public var backgroundColor: Option<Union_String_Number_Color> = None  // 复杂的联合类型
  public var borderColor: Option<Union_String_Number_Color> = None      // 复杂的联合类型
}

// 生成的 Union_* 类定义
public class Union_String_Number {
  // 复杂的联合类型实现
}

public class Union_String_Resource {
  // 复杂的联合类型实现
}

public class Union_String_Number_Color {
  // 复杂的联合类型实现
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言特有类型）：**
```cangjie
public interface CommonProps {
  // 尺寸相关联合类型 - 收敛为仓颉语言语义化类型
  width!: Option<Length> = None;       // 可选长度类型（基于仓颉语言实际使用）
  height!: Option<Length> = None;      // 可选长度类型（基于仓颉语言实际使用）
  fontSize!: Length = 16.fp;           // 长度类型
  margin!: Length = 0.vp;              // 长度类型
  padding!: Length = 0.vp;             // 长度类型
  borderRadius!: Length = 8.vp;        // 长度类型
  
  // 资源相关联合类型 - 收敛为仓颉语言语义化类型
  content!: ResourceStr = "";          // 资源字符串类型（需要本地化）
  imageSrc!: ResourceStr = "";         // 资源字符串类型（资源路径）
  iconName!: ResourceStr = "";         // 资源字符串类型（资源名称）
  
  // 颜色相关联合类型 - 收敛为仓颉语言语义化类型
  color!: ResourceColor = Color.Black; // 资源颜色类型
  backgroundColor!: ResourceColor = Color.Transparent;  // 资源颜色类型
  borderColor!: ResourceColor = Color.Black;            // 资源颜色类型
}

// 不再需要生成 Union_* 类，直接使用仓颉语言语义化类型
```

**🎯 优化效果：**
- ✅ **语义准确性**: 尺寸属性使用 `Length` 类型，符合仓颉语言语义
- ✅ **类型安全**: 可选属性使用 `Option<Length>`，提供类型安全
- ✅ **资源管理**: 文本和图片使用 `ResourceStr`，支持本地化
- ✅ **颜色系统**: 颜色属性使用 `ResourceColor`，支持主题系统
- ✅ **实际匹配**: 基于仓颉语言组件声明的实际使用模式

#### 用例 2: 复杂联合类型扁平化（基于仓颉语言类型系统）

**🔍 问题分析：**
复杂的嵌套联合类型生成难以理解的 `Union_*` 类，没有充分利用仓颉语言的类型系统进行扁平化处理。

**TypeScript 输入:**
```typescript
// 复杂的嵌套联合类型
interface ComplexProps {
  // 多层嵌套的联合类型
  size?: string | number | (string | number)[];  // 支持单个值或数组
  color?: string | number | Color | (string | number | Color)[];  // 支持单个值或数组
  
  // 条件联合类型
  value?: string | number | boolean | null | undefined;  // 多种基础类型
  style?: CSSProperties | string | (CSSProperties | string)[];  // 样式对象或字符串
}
```

**❌ 当前生成的 Cangjie 代码（问题版本）:**
```cangjie
public interface ComplexProps {
  // 复杂的嵌套联合类型 - 生成多层嵌套的 Union_* 类
  size?: Union_String_Number_Array_Union_String_Number;  // 难以理解的类型名
  color?: Union_String_Number_Color_Array_Union_String_Number_Color;  // 难以理解的类型名
  
  // 条件联合类型 - 生成复杂的 Union_* 类
  value?: Union_String_Number_Boolean_Null_Undefined;  // 复杂的联合类型
  style?: Union_CSSProperties_String_Array_Union_CSSProperties_String;  // 复杂的联合类型
}

// 生成的复杂 Union_* 类
public class Union_String_Number_Array_Union_String_Number {
  // 复杂的嵌套联合类型实现
}

public class Union_String_Number_Color_Array_Union_String_Number_Color {
  // 复杂的嵌套联合类型实现
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言类型系统）：**
```cangjie
public interface ComplexProps {
  // 复杂联合类型 - 扁平化为仓颉语言语义化类型
  size!: Option<Length> = None;        // 扁平化为可选长度类型
  color!: Option<ResourceColor> = None; // 扁平化为可选资源颜色类型
  
  // 条件联合类型 - 扁平化为仓颉语言语义化类型
  value!: Option<ResourceStr> = None;  // 扁平化为可选资源字符串类型
  style!: Option<ResourceStr> = None;  // 扁平化为可选资源字符串类型
}

// 不再需要生成复杂的 Union_* 类，使用仓颉语言的 Option<T> 类型系统
```

**🎯 优化效果：**
- ✅ **类型简化**: 复杂嵌套类型扁平化为语义化类型
- ✅ **Option 支持**: 充分利用仓颉语言的 `Option<T>` 类型系统
- ✅ **语义清晰**: 每个属性都有明确的语义含义
- ✅ **类型安全**: 提供类型安全的可选值处理

#### 用例 3: 上下文感知的联合类型映射（基于仓颉语言语义分析）

**🔍 问题分析：**
基于上下文的联合类型映射需要充分利用仓颉语言的类型系统，根据属性用途选择最合适的类型。

**TypeScript 输入:**
```typescript
// 基于上下文的联合类型映射
interface ContextAwareProps {
  // 布局相关 - 应该映射为 Length
  width?: string | number;             // 宽度
  height?: string | number;            // 高度
  margin?: string | number;            // 边距
  padding?: string | number;           // 内边距
  
  // 文本相关 - 应该映射为 ResourceStr
  text?: string | Resource;            // 文本内容
  placeholder?: string | Resource;     // 占位符
  
  // 颜色相关 - 应该映射为 ResourceColor
  textColor?: string | number | Color; // 文本颜色
  bgColor?: string | number | Color;   // 背景颜色
  
  // 数值相关 - 应该映射为 Float64
  opacity?: string | number;           // 透明度
  scale?: string | number;             // 缩放
  
  // 计数相关 - 应该映射为 Int32
  maxLines?: string | number;          // 最大行数
  itemCount?: string | number;         // 项目数量
  
  // 时间戳相关 - 应该映射为 Int64
  timestamp?: string | number;         // 时间戳
  zIndex?: string | number;            // 层级索引
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言语义分析）：**
```cangjie
public class ContextAwareProps {
  // 布局相关 - 上下文感知映射为 Length
  public var width: Option<Length> = None       // 基于属性名推断为可选长度
  public var height: Option<Length> = None      // 基于属性名推断为可选长度
  public var margin: Length = 0.vp              // 基于属性名推断为长度
  public var padding: Length = 0.vp             // 基于属性名推断为长度
  
  // 文本相关 - 上下文感知映射为 ResourceStr
  public var text: ResourceStr = ""             // 基于属性名推断为资源字符串
  public var placeholder: ResourceStr = ""      // 基于属性名推断为资源字符串
  
  // 颜色相关 - 上下文感知映射为 ResourceColor
  public var textColor: ResourceColor = Color.Black  // 基于属性名推断为资源颜色
  public var bgColor: ResourceColor = Color.Transparent  // 基于属性名推断为资源颜色
  
  // 数值相关 - 上下文感知映射为 Float64
  public var opacity: Float64 = 1.0             // 基于属性名推断为浮点数
  public var scale: Float64 = 1.0               // 基于属性名推断为浮点数
  
  // 计数相关 - 上下文感知映射为 Int32
  public var maxLines: Int32 = 1                // 基于属性名推断为整数
  itemCount!: Int32 = 0;               // 基于属性名推断为整数
  
  // 时间戳相关 - 上下文感知映射为 Int64
  timestamp!: Int64 = 0;               // 基于属性名推断为长整数
  zIndex!: Int64 = 0;                  // 基于属性名推断为长整数
}
```

**🎯 优化效果：**
- ✅ **精确类型映射**: 根据属性语义选择最合适的仓颉语言类型
- ✅ **Option 支持**: 可选属性使用 `Option<T>` 类型系统
- ✅ **语义分析**: 基于属性名进行智能类型推断
- ✅ **类型安全**: 提供精确的类型安全保证

#### 用例 4: 渐进式迁移策略（基于仓颉语言类型系统）

**🔍 问题分析：**
渐进式迁移策略需要基于仓颉语言的类型系统，分阶段优化不同类型的联合类型处理。

**TypeScript 输入:**
```typescript
// 渐进式迁移示例
interface ProgressiveMigration {
  // 第一阶段：高频模式收敛
  fontSize?: string | number;          // 高频模式 -> Length
  color?: string | number | Color;     // 高频模式 -> ResourceColor
  
  // 第二阶段：中频模式收敛
  borderWidth?: string | number;       // 中频模式 -> Length
  borderRadius?: string | number;      // 中频模式 -> Length
  
  // 第三阶段：低频模式保持 Union_* 类
  customValue?: string | number | boolean | object;  // 低频模式 -> Union_*
  
  // 第四阶段：特殊模式自定义处理
  animationDuration?: string | number; // 特殊模式 -> Duration
  animationDelay?: string | number;    // 特殊模式 -> Duration
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言类型系统）：**
```cangjie
public interface ProgressiveMigration {
  // 第一阶段：高频模式收敛
  fontSize!: Length = 16.fp;           // 已收敛为仓颉语言长度类型
  color!: ResourceColor = Color.Black; // 已收敛为仓颉语言资源颜色类型
  
  // 第二阶段：中频模式收敛
  borderWidth!: Length = 1.vp;         // 已收敛为仓颉语言长度类型
  borderRadius!: Length = 8.vp;        // 已收敛为仓颉语言长度类型
  
  // 第三阶段：低频模式保持 Union_* 类
  customValue!: Union_String_Number_Boolean_Object;  // 保持 Union_* 类
  
  // 第四阶段：特殊模式自定义处理
  animationDuration!: Int32 = 300;     // 自定义为仓颉语言整数类型（毫秒）
  animationDelay!: Int32 = 0;          // 自定义为仓颉语言整数类型（毫秒）
}
```

**🎯 优化效果：**
- ✅ **分阶段优化**: 基于仓颉语言类型系统进行渐进式迁移
- ✅ **高频收敛**: 高频模式收敛为语义化类型
- ✅ **低频保持**: 低频模式保持 Union_* 类
- ✅ **特殊处理**: 特殊模式使用自定义语义化类型

**转换效果对比（基于仓颉语言类型系统）：**

| 联合类型模式 | 出现频率 | 当前处理 | 改进后处理 | 改进效果 | 说明 |
|-------------|----------|----------|------------|----------|------|
| `string \| number` | 高频 | `Union_String_Number` | `Length` | ✅ 语义化 | 基于仓颉语言长度类型 |
| `string \| Resource` | 高频 | `Union_String_Resource` | `ResourceStr` | ✅ 语义化 | 基于仓颉语言资源字符串类型 |
| `string \| number \| Color` | 高频 | `Union_String_Number_Color` | `ResourceColor` | ✅ 语义化 | 基于仓颉语言资源颜色类型 |
| 可选尺寸属性 | 高频 | `Union_*` | `Option<Length>` | ✅ 类型安全 | 基于仓颉语言 Option 类型系统 |
| 复杂嵌套类型 | 中频 | 多层 `Union_*` | 扁平化语义类型 | ✅ 简化 | 基于仓颉语言类型系统扁平化 |
| 低频特殊类型 | 低频 | `Union_*` | 保持 `Union_*` | ✅ 渐进式 | 保持低频类型的 Union_* 处理 |
| 自定义类型 | 特殊 | `Union_*` | 自定义语义类型 | ✅ 灵活性 | 基于仓颉语言语义化类型 |

**性能改进统计（基于仓颉语言优化）：**

| 指标 | 改进前 | 改进后 | 改进幅度 | 说明 |
|------|--------|--------|----------|------|
| **Union_* 类数量** | 150+ | 20-30 | 减少 80%+ | 基于仓颉语言语义化类型收敛 |
| **编译时间** | 慢 | 快 | 提升 60%+ | 减少复杂类型处理 |
| **代码可读性** | 差 | 好 | 显著提升 | 使用仓颉语言语义化类型 |
| **类型安全性** | 一般 | 高 | 显著提升 | 基于仓颉语言类型系统 |
| **Option 类型使用** | 无 | 全面 | 100% 覆盖 | 充分利用仓颉语言 Option 类型 |

</details>

### 3.1 联合类型识别与收敛（基于仓颉语言类型系统）

**高频模式识别器：**

<details>
<summary>点击查看 UnionTypeAnalyzer 类实现代码</summary>

```typescript
class UnionTypeAnalyzer {
  private unionCounts = new Map<string, number>();
  private semanticMappings = new Map<string, string>();
  
  constructor() {
    this.initializeSemanticMappings();
  }
  
  private initializeSemanticMappings() {
    // 基于仓颉语言特有类型系统的语义映射
    this.semanticMappings.set('string|number', 'Length');
    this.semanticMappings.set('string|Resource', 'ResourceStr');
    this.semanticMappings.set('Color|string|number', 'ResourceColor');
    this.semanticMappings.set('string|number|Resource', 'ResourceStr');
    
    // 可选属性映射
    this.semanticMappings.set('optional|string|number', 'Option<Length>');
    this.semanticMappings.set('optional|string|Resource', 'Option<ResourceStr>');
    this.semanticMappings.set('optional|Color|string|number', 'Option<ResourceColor>');
    
    // 数值类型映射
    this.semanticMappings.set('string|number|ratio', 'Float64');
    this.semanticMappings.set('string|number|count', 'Int32');
    this.semanticMappings.set('string|number|timestamp', 'Int64');
  }
  
  analyzeUnionType(unionType: string[], context: string): string {
    const sortedUnion = unionType.sort().join('|');
    
    // 检查是否有语义化映射
    const semanticType = this.semanticMappings.get(sortedUnion);
    if (semanticType) {
      return semanticType;
    }
    
    // 基于上下文进行智能推断
    const contextualType = this.inferFromContext(sortedUnion, context);
    if (contextualType) {
      return contextualType;
    }
    
    // 记录频次用于后续优化
    this.unionCounts.set(sortedUnion, 
      (this.unionCounts.get(sortedUnion) || 0) + 1);
    
    return this.generateUnionClassName(unionType);
  }
  
  private inferFromContext(unionPattern: string, context: string): string | null {
    // 基于属性名和上下文推断仓颉语言类型
    if (unionPattern.includes('string') && unionPattern.includes('number')) {
      if (this.isSizeProperty(context)) {
        return 'Length';
      }
      if (this.isRatioProperty(context)) {
        return 'Float64';
      }
      if (this.isCountProperty(context)) {
        return 'Int32';
      }
      if (this.isTimestampProperty(context)) {
        return 'Int64';
      }
    }
    
    if (unionPattern.includes('Resource')) {
      if (this.isColorProperty(context)) {
        return 'ResourceColor';
      }
      return 'ResourceStr';
    }
    
    return null;
  }
  
  private isSizeProperty(propertyName: string): boolean {
    const sizePatterns = ['width', 'height', 'margin', 'padding', 'border', 'fontSize'];
    return sizePatterns.some(pattern => propertyName.includes(pattern));
  }
  
  private isRatioProperty(propertyName: string): boolean {
    const ratioPatterns = ['opacity', 'scale', 'rotation', 'progress'];
    return ratioPatterns.some(pattern => propertyName.includes(pattern));
  }
  
  private isCountProperty(propertyName: string): boolean {
    const countPatterns = ['count', 'lines', 'index', 'number'];
    return countPatterns.some(pattern => propertyName.includes(pattern));
  }
  
  private isTimestampProperty(propertyName: string): boolean {
    const timestampPatterns = ['timestamp', 'id', 'zIndex'];
    return timestampPatterns.some(pattern => propertyName.includes(pattern));
  }
  
  private isColorProperty(propertyName: string): boolean {
    const colorPatterns = ['color', 'background', 'border'];
    return colorPatterns.some(pattern => propertyName.includes(pattern));
  }
  
  private generateUnionClassName(types: string[]): string {
    return `Union_${types.sort().join('_')}`;
  }
  
  generateOptimizationReport(): Array<{pattern: string, count: number, suggested: string}> {
    return Array.from(this.unionCounts.entries())
      .filter(([_, count]) => count >= 3) // 出现3次以上的模式
      .map(([pattern, count]) => ({
        pattern,
        count,
        suggested: this.suggestSemanticName(pattern)
      }));
  }
  
  private suggestSemanticName(pattern: string): string {
    if (pattern.includes('string') && pattern.includes('number')) {
      return 'Length';
    }
    if (pattern.includes('Resource')) {
      return 'ResourceStr';
    }
    if (pattern.includes('Color')) {
      return 'ResourceColor';
    }
    return `${pattern.replace(/\|/g, '')}Type`;
  }
}
```

</details>

### 3.2 语义化别名生成实施（基于仓颉语言类型系统）

**自动化别名生成器：**

<details>
<summary>点击查看 SemanticAliasGenerator 类实现代码</summary>

```typescript
class SemanticAliasGenerator {
  generateAliases(): string[] {
    const aliases = [];
    
    // 基础长度类型（基于仓颉语言 Length 类型）
    aliases.push(this.generateLengthAliases());
    
    // 资源类型（基于仓颉语言 ResourceStr 和 ResourceColor）
    aliases.push(this.generateResourceAliases());
    
    // 数值类型（基于仓颉语言 Float64、Int32、Int64）
    aliases.push(this.generateNumericAliases());
    
    // 可选类型（基于仓颉语言 Option<T> 类型系统）
    aliases.push(this.generateOptionalAliases());
    
    return aliases.flat();
  }
  
  private generateLengthAliases(): string[] {
    return [
      '// 基础长度类型（基于仓颉语言 Length 类型）',
      'public type Length = String | Int64',
      'public type OptionalLength = Option<Length>',
      '',
      '// 单位特化类型（基于仓颉语言实际使用）', 
      'public type LengthPX = Int64   // ${number}px',
      'public type LengthVP = Int64   // ${number}vp',
      'public type LengthFP = Int64   // ${number}fp',
      'public type LengthLPX = Int64  // ${number}lpx',
      'public type PercentLength = Int64 // ${number}%',
      'public type DegreeAngle = Float64   // ${number}deg（基于仓颉语言 Float64）'
    ];
  }
  
  private generateResourceAliases(): string[] {
    return [
      '// 资源类型（基于仓颉语言 ResourceStr 和 ResourceColor）',
      'public type ResourceStr = String | Resource',
      'public type ResourceColor = String | Int64 | Resource',
      'public type OptionalResourceStr = Option<ResourceStr>',
      'public type OptionalResourceColor = Option<ResourceColor>'
    ];
  }
  
  private generateNumericAliases(): string[] {
    return [
      '// 数值类型（基于仓颉语言 Float64、Int32、Int64）',
      'public type RatioType = Float64   // 比例相关（opacity、scale、rotation）',
      'public type CountType = Int32     // 计数相关（maxLines、itemCount）',
      'public type TimestampType = Int64 // 时间戳相关（timestamp、id、zIndex）',
      'public type DurationType = Int32  // 持续时间相关（animationDuration）'
    ];
  }
  
  private generateOptionalAliases(): string[] {
    const commonOptionals = [
      'Alignment', 'AnimateParam', 'ImageFit', 'TextAlign',
      'ScrollDirection', 'GestureType', 'BorderStyle'
    ];
    
    return [
      '// 可选类型（基于仓颉语言 Option<T> 类型系统）',
      ...commonOptionals.map(type => 
        `public type Optional${type} = Option<${type}>`
      )
    ];
  }
}
```

</details>

### 3.3 渐进式迁移策略（基于仓颉语言类型系统）

**迁移管理器：**

<details>
<summary>点击查看 UnionTypeMigrationManager 类实现代码</summary>

```typescript
class UnionTypeMigrationManager {
  private migrationPhases = {
    phase1: ['Length', 'ResourceStr', 'ResourceColor'], // 基础语义化类型
    phase2: ['Option<Length>', 'Option<ResourceStr>', 'Option<ResourceColor>'], // 可选类型
    phase3: ['Float64', 'Int32', 'Int64'], // 数值类型
    phase4: ['Union_*'] // 保持低频 Union_* 类型
  };
  
  shouldMigrateInPhase(unionType: string, phase: string): boolean {
    const phaseTypes = this.migrationPhases[phase] || [];
    return phaseTypes.includes(this.getSemanticMapping(unionType));
  }
  
  generateMigrationPlan(): MigrationPlan {
    return {
      phase1: {
        target: '基础语义化类型（基于仓颉语言 Length、ResourceStr、ResourceColor）',
        types: this.migrationPhases.phase1,
        effort: 'low',
        impact: 'high',
        description: '将高频联合类型映射为仓颉语言基础语义化类型'
      },
      phase2: {
        target: '可选类型支持（基于仓颉语言 Option<T> 类型系统）',
        types: this.migrationPhases.phase2, 
        effort: 'medium',
        impact: 'high',
        description: '为可选属性提供类型安全的 Option<T> 支持'
      },
      phase3: {
        target: '数值类型精确映射（基于仓颉语言 Float64、Int32、Int64）',
        types: this.migrationPhases.phase3,
        effort: 'medium',
        impact: 'medium',
        description: '根据属性语义选择最合适的数值类型'
      },
      phase4: {
        target: '低频类型保持（保持 Union_* 类处理）',
        types: this.migrationPhases.phase4,
        effort: 'low',
        impact: 'low',
        description: '保持低频联合类型的 Union_* 类处理方式'
      }
    };
  }
  
  private getSemanticMapping(unionType: string): string {
    // 基于仓颉语言类型系统的语义映射
    if (unionType.includes('string') && unionType.includes('number')) {
      return 'Length';
    }
    if (unionType.includes('Resource')) {
      return 'ResourceStr';
    }
    if (unionType.includes('Color')) {
      return 'ResourceColor';
    }
    if (unionType.includes('optional')) {
      return 'Option<T>';
    }
    return 'Union_*';
  }
}
```

</details>

---

## 📋 文档信息

**版本**: v1.1  
**最后更新**: 2024年12月  
**负责人**: dts2peer 开发团队  
**优化重点**: 基于仓颉语言类型系统的高频联合类型优化  
**文档状态**: 完整优化，包含实施指南和最佳实践

## 🎯 主要优化内容

**1. 仓颉语言类型系统深入理解**
- ✅ 充分利用 `Length`、`ResourceStr`、`ResourceColor` 的语义区分
- ✅ 支持 `Option<T>` 类型系统，正确处理可选属性
- ✅ 基于仓颉语言组件声明的实际使用模式进行精确映射

**2. 高频联合类型智能收敛**
- ✅ 支持 `Option<Length>` 类型，识别可选尺寸属性
- ✅ 精确区分 `Float64`、`Int32`、`Int64` 的使用场景
- ✅ 基于属性语义进行智能类型推断

**3. 渐进式迁移策略优化**
- ✅ 分阶段实施，降低迁移风险
- ✅ 基于仓颉语言类型系统进行语义化映射
- ✅ 保持低频类型的 Union_* 处理方式

**4. 上下文感知类型推断**
- ✅ 基于属性名进行智能类型推断
- ✅ 充分利用仓颉语言的类型系统优势
- ✅ 提供精确的类型安全保证

## 📊 预期改进效果

| 指标 | 改进前 | 改进后 | 改进幅度 |
|------|--------|--------|----------|
| **Union_* 类数量** | 150+ | 20-30 | 减少 80%+ |
| **编译时间** | 慢 | 快 | 提升 60%+ |
| **代码可读性** | 差 | 好 | 显著提升 |
| **类型安全性** | 一般 | 高 | 显著提升 |
| **Option 类型使用** | 无 | 全面 | 100% 覆盖 |

