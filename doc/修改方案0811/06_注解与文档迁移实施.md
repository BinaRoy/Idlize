## 6. 注解与文档迁移实施 v1.1

### 📋 修改说明

**🔍 问题分析：**
当前 `dts2peer` 工具在注解和文档处理方面的不足：
- TypeScript 中的 JSDoc 注释和装饰器信息丢失
- 缺乏 Cangjie 标准注解（`@!APILevel`、`@relation` 等）的自动生成
- API 版本信息没有正确迁移到 Cangjie 注解系统
- 生成的代码缺乏必要的文档和元数据支持

**仓颉语言特有问题：**
- 没有充分利用仓颉语言的注解系统（`@!APILevel`、`@Derive[Equatable]`、`@relation`）
- JSDoc 注释没有转换为仓颉语言兼容的文档格式
- 缺乏对仓颉语言特有类型（如 `ResourceStr`、`Length`、`ResourceColor`）的注解支持
- 示例代码没有转换为仓颉语言语法

**🎯 优化策略：**
1. **注解映射系统**：建立 TypeScript 装饰器/JSDoc 到 Cangjie 注解的映射规则
2. **API 级别推断**：根据 TypeScript 版本信息自动推断并生成 `@!APILevel` 注解
3. **文档格式转换**：将 JSDoc 注释转换为 Cangjie 兼容的文档格式
4. **依赖关系分析**：自动分析并生成 `@relation` 注解

**🎯 最终目标：**
- 保留 TypeScript 代码中的重要元数据信息
- 确保生成的 Cangjie 代码符合官方注解规范
- 提供完整的 API 文档和版本信息
- 支持 IDE 和工具链的智能提示功能
- 充分利用仓颉语言的注解系统和文档格式

### 📋 转换用例示例

<details>
<summary>点击查看完整的转换用例</summary>

#### 用例 1: JSDoc 到 Cangjie 注解转换（基于仓颉语言注解系统和文档格式）

**🔍 问题分析：**
TypeScript 的 JSDoc 注释和装饰器信息在转换过程中丢失，导致生成的仓颉语言代码缺乏必要的文档和元数据支持，不符合仓颉语言的注解规范。

**TypeScript 输入:**
```typescript
/**
 * 按钮组件接口定义
 * @since API 12
 * @version 1.0.0
 * @deprecated 使用 ButtonProps 替代
 */
interface ButtonInterface {
  /**
   * 按钮文本内容
   * @default "Button"
   * @example
   * ```typescript
   * <Button text="Click me" />
   * ```
   */
  text?: string;
  
  /**
   * 按钮类型
   * @default "normal"
   * @since API 11
   */
  type?: 'normal' | 'capsule' | 'circle';
  
  /**
   * 按钮点击事件回调
   * @param event 点击事件对象
   * @example
   * ```typescript
   * <Button onClick={(event) => console.log('clicked')} />
   * ```
   */
  onClick?: (event: ClickEvent) => void;
  
  /**
   * 按钮是否可见
   * @default true
   * @deprecated 使用 visible 属性替代
   */
  show?: boolean;
}

/**
 * 文本组件接口定义
 * @since API 9
 * @relation TextInput, RichText
 */
interface TextInterface {
  /**
   * 文本内容
   * @required
   */
  content: string;
  
  /**
   * 字体大小
   * @default 16
   * @unit px
   */
  fontSize?: number;
}
```

**❌ 当前生成的 Cangjie 代码（问题版本）：**
```cangjie
// 注解和文档信息丢失
public interface ButtonInterface {
  text?: String;
  type?: Union_Normal_Capsule_Circle;
  onClick?: Callback_ClickEvent_Void;
  show?: Bool;
}

public interface TextInterface {
  content: String;
  fontSize?: Int64;
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言注解系统/文档格式）：**
```cangjie
/**
 * 按钮组件接口定义
 * @since API 12
 * @version 1.0.0
 * @deprecated 使用 ButtonProps 替代
 */
@!APILevel[12]
@relation[ButtonProps]
public interface ButtonInterface {
  /**
   * 按钮文本内容
   * @default "Button"
   * @example
   * ```cangjie
   * Button().setText("Click me")
   * ```
   */
  text!: ResourceStr = "Button";
  
  /**
   * 按钮类型
   * @default "normal"
   * @since API 11
   */
  @!APILevel[11]
  type!: ButtonType = ButtonType.Normal;
  
  /**
   * 按钮点击事件回调
   * @param event 点击事件对象
   * @example
   * ```cangjie
   * Button().setOnClick { event => println("clicked") }
   * ```
   */
  onClick!: Option<(ClickEvent) -> Unit> = None;
  
  /**
   * 按钮是否可见
   * @default true
   * @deprecated 使用 visible 属性替代
   */
  @deprecated
  show!: Bool = true;
}

/**
 * 文本组件接口定义
 * @since API 9
 * @relation TextInput, RichText
 */
@!APILevel[9]
@relation[TextInput, RichText]
public interface TextInterface {
  /**
   * 文本内容
   * @required
   */
  content: ResourceStr;
  
  /**
   * 字体大小
   * @default 16
   * @unit px
   */
  fontSize!: Length = 16.fp;
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的 `@!APILevel` 注解，提供版本信息
- ✅ 使用仓颉语言的 `@relation` 注解，建立组件关系
- ✅ 使用仓颉语言的语义化类型（`ResourceStr`、`Length`）
- ✅ 转换示例代码为仓颉语言语法
- ✅ 保留完整的 JSDoc 文档信息

#### 用例 2: API Level 注解自动生成（基于仓颉语言注解系统）

**🔍 问题分析：**
TypeScript 的 API 版本信息没有正确迁移到仓颉语言的 `@!APILevel` 注解系统，导致生成的代码缺乏版本兼容性信息。

**TypeScript 输入:**
```typescript
/**
 * 基础组件接口
 * @since API 9
 */
interface BaseComponent {
  id?: string;
  visible?: boolean;
}

/**
 * 高级组件接口
 * @since API 12
 * @requires BaseComponent
 */
interface AdvancedComponent extends BaseComponent {
  /**
   * 动画效果
   * @since API 11
   */
  animation?: boolean;
  
  /**
   * 3D 变换
   * @since API 13
   */
  transform3D?: boolean;
}

/**
 * 实验性功能接口
 * @since API 14
 * @experimental
 */
interface ExperimentalComponent {
  /**
   * 实验性属性
   * @since API 14
   * @experimental
   */
  experimentalFeature?: boolean;
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言注解系统）：**
```cangjie
/**
 * 基础组件接口
 * @since API 9
 */
@!APILevel[9]
public class BaseComponent {
  public var id: Option<String> = None
  public var visible: Bool = true
}

/**
 * 高级组件接口
 * @since API 12
 * @requires BaseComponent
 */
@!APILevel[12]
@relation[BaseComponent]
public class AdvancedComponent <: BaseComponent {
  /**
   * 动画效果
   * @since API 11
   */
  @!APILevel[11]
  public var animation: Bool = false
  
  /**
   * 3D 变换
   * @since API 13
   */
  @!APILevel[13]
  public var transform3D: Bool = false
}

/**
 * 实验性功能接口
 * @since API 14
 * @experimental
 */
@!APILevel[14]
@experimental
public class ExperimentalComponent {
  /**
   * 实验性属性
   * @since API 14
   * @experimental
   */
  @!APILevel[14]
  @experimental
  public var experimentalFeature: Bool = false
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的 `@!APILevel` 注解，提供精确的版本信息
- ✅ 使用仓颉语言的 `@relation` 注解，建立组件继承关系
- ✅ 使用仓颉语言的 `@experimental` 注解，标记实验性功能
- ✅ 使用仓颉语言的 `Option<T>` 类型系统处理可选属性
- ✅ 提供类型安全的默认值

#### 用例 3: 依赖关系注解生成（基于仓颉语言注解系统）

**🔍 问题分析：**
TypeScript 的依赖关系信息（`@see`、`@extends`）没有转换为仓颉语言的 `@relation` 注解，导致组件间的关系信息丢失。

**TypeScript 输入:**
```typescript
/**
 * 布局容器组件
 * @since API 9
 * @see Column, Row, Flex
 */
interface ContainerProps {
  children?: ReactNode[];
  direction?: 'horizontal' | 'vertical';
}

/**
 * 垂直布局组件
 * @since API 9
 * @extends ContainerProps
 */
interface ColumnProps extends ContainerProps {
  justifyContent?: 'start' | 'center' | 'end' | 'space-between';
}

/**
 * 水平布局组件
 * @since API 9
 * @extends ContainerProps
 */
interface RowProps extends ContainerProps {
  alignItems?: 'start' | 'center' | 'end' | 'stretch';
}

/**
 * 弹性布局组件
 * @since API 10
 * @extends ContainerProps
 * @see Column, Row
 */
interface FlexProps extends ContainerProps {
  flexDirection?: 'row' | 'column';
  flexWrap?: 'nowrap' | 'wrap';
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言注解系统）：**
```cangjie
/**
 * 布局容器组件
 * @since API 9
 * @see Column, Row, Flex
 */
@!APILevel[9]
@relation[Column, Row, Flex]
public interface ContainerProps {
  children!: Option<ArrayList<ReactNode>> = None;
  direction!: LayoutDirection = LayoutDirection.Vertical;
}

/**
 * 垂直布局组件
 * @since API 9
 * @extends ContainerProps
 */
@!APILevel[9]
@relation[ContainerProps]
public interface ColumnProps <: ContainerProps {
  justifyContent!: FlexAlign = FlexAlign.Start;
}

/**
 * 水平布局组件
 * @since API 9
 * @extends ContainerProps
 */
@!APILevel[9]
@relation[ContainerProps]
public interface RowProps <: ContainerProps {
  alignItems!: HorizontalAlign = HorizontalAlign.Start;
}

/**
 * 弹性布局组件
 * @since API 10
 * @extends ContainerProps
 * @see Column, Row
 */
@!APILevel[10]
@relation[ContainerProps, Column, Row]
public interface FlexProps <: ContainerProps {
  flexDirection!: FlexDirection = FlexDirection.Row;
  flexWrap!: FlexWrap = FlexWrap.Nowrap;
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的 `@relation` 注解，建立组件依赖关系
- ✅ 使用仓颉语言的语义化类型（`LayoutDirection`、`FlexAlign`、`HorizontalAlign`）
- ✅ 使用仓颉语言的 `Option<T>` 和 `ArrayList<T>` 类型系统
- ✅ 保留完整的继承关系信息
- ✅ 提供类型安全的默认值

#### 用例 4: 复杂注解组合（基于仓颉语言注解系统）

**🔍 问题分析：**
复杂的 TypeScript 注解组合（版本信息、废弃标记、实验性标记等）没有正确转换为仓颉语言的注解系统，导致重要的元数据信息丢失。

**TypeScript 输入:**
```typescript
/**
 * 复杂组件接口
 * @since API 12
 * @version 2.0.0
 * @author HarmonyOS Team
 * @deprecated 使用 NewComponent 替代
 * @experimental
 * @see NewComponent, LegacyComponent
 * @example
 * ```typescript
 * <ComplexComponent
 *   data={items}
 *   onItemClick={handleClick}
 *   theme="dark"
 * />
 * ```
 */
interface ComplexComponent {
  /**
   * 数据源
   * @required
   * @since API 12
   * @type Array<T>
   */
  data: any[];
  
  /**
   * 主题设置
   * @default "light"
   * @since API 11
   * @deprecated 使用 themeMode 替代
   */
  theme?: 'light' | 'dark' | 'auto';
  
  /**
   * 项目点击事件
   * @param item 点击的项目
   * @param index 项目索引
   * @since API 12
   * @example
   * ```typescript
   * onItemClick={(item, index) => {
   *   console.log('Clicked item:', item, 'at index:', index);
   * }}
   * ```
   */
  onItemClick?: (item: any, index: number) => void;
  
  /**
   * 实验性功能
   * @since API 13
   * @experimental
   * @internal
   */
  experimentalFeature?: boolean;
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言注解系统）：**
```cangjie
/**
 * 复杂组件接口
 * @since API 12
 * @version 2.0.0
 * @author HarmonyOS Team
 * @deprecated 使用 NewComponent 替代
 * @experimental
 * @see NewComponent, LegacyComponent
 * @example
 * ```cangjie
 * ComplexComponent()
 *   .setData(items)
 *   .setOnItemClick { item, index => handleClick(item, index) }
 *   .setTheme(ThemeType.Dark)
 * ```
 */
@!APILevel[12]
@relation[NewComponent, LegacyComponent]
@deprecated
@experimental
public interface ComplexComponent {
  /**
   * 数据源
   * @required
   * @since API 12
   * @type Array<T>
   */
  data: ArrayList<Any>;
  
  /**
   * 主题设置
   * @default "light"
   * @since API 11
   * @deprecated 使用 themeMode 替代
   */
  @!APILevel[11]
  @deprecated
  theme!: ThemeType = ThemeType.Light;
  
  /**
   * 项目点击事件
   * @param item 点击的项目
   * @param index 项目索引
   * @since API 12
   * @example
   * ```cangjie
   * setOnItemClick { item, index =>
   *   println("Clicked item: ${item} at index: ${index}")
   * }
   * ```
   */
  @!APILevel[12]
  onItemClick!: Option<(Any, Int64) -> Unit> = None;
  
  /**
   * 实验性功能
   * @since API 13
   * @experimental
   * @internal
   */
  @!APILevel[13]
  @experimental
  @internal
  experimentalFeature!: Bool = false;
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的复杂注解组合（`@!APILevel`、`@relation`、`@deprecated`、`@experimental`）
- ✅ 使用仓颉语言的语义化类型（`ArrayList<Any>`、`ThemeType`、`Option<T>`）
- ✅ 转换示例代码为仓颉语言语法
- ✅ 保留完整的元数据信息
- ✅ 提供类型安全的默认值

#### 用例 5: 文档格式标准化（基于仓颉语言文档格式）

**🔍 问题分析：**
TypeScript 的 JSDoc 文档格式没有标准化转换为仓颉语言兼容的文档格式，导致文档的可读性和一致性不足。

**TypeScript 输入:**
```typescript
/**
 * 标准化的组件接口
 * @description 这是一个标准化的组件接口，用于演示文档格式转换
 * @since API 12
 * @category UI Components
 * @tags button, interactive, form
 */
interface StandardizedComponent {
  /**
   * 组件标题
   * @description 显示在组件上的标题文本
   * @default "Default Title"
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9\s]+$
   */
  title?: string;
  
  /**
   * 组件描述
   * @description 组件的详细描述信息
   * @optional
   * @maxLength 500
   */
  description?: string;
  
  /**
   * 组件状态
   * @description 组件的当前状态
   * @default "normal"
   * @enum normal, disabled, loading, error
   */
  status?: 'normal' | 'disabled' | 'loading' | 'error';
  
  /**
   * 自定义样式
   * @description 组件的自定义样式对象
   * @optional
   * @type CSSProperties
   */
  style?: CSSProperties;
}
```

**✅ 改进后的 Cangjie 代码（基于仓颉语言文档格式）：**
```cangjie
/**
 * 标准化的组件接口
 * @description 这是一个标准化的组件接口，用于演示文档格式转换
 * @since API 12
 * @category UI Components
 * @tags button, interactive, form
 */
@!APILevel[12]
@category[UI Components]
@tags[button, interactive, form]
public class StandardizedComponent {
  /**
   * 组件标题
   * @description 显示在组件上的标题文本
   * @default "Default Title"
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9\s]+$
   */
  public var title: ResourceStr = "Default Title"
  
  /**
   * 组件描述
   * @description 组件的详细描述信息
   * @optional
   * @maxLength 500
   */
  public var description: Option<ResourceStr> = None
  
  /**
   * 组件状态
   * @description 组件的当前状态
   * @default "normal"
   * @enum normal, disabled, loading, error
   */
  public var status: ComponentStatus = ComponentStatus.Normal
  
  /**
   * 自定义样式
   * @description 组件的自定义样式对象
   * @optional
   * @type CSSProperties
   */
  public var style: Option<CSSProperties> = None
}

// 自动生成的枚举类型
@Derive[Equatable]
@!APILevel[12]
public enum ComponentStatus {
  Normal,
  Disabled,
  Loading,
  Error
}
```

**🎯 优化效果：**
- ✅ 使用仓颉语言的标准化文档格式
- ✅ 使用仓颉语言的语义化类型（`ResourceStr`、`Option<T>`）
- ✅ 使用仓颉语言的枚举类型系统
- ✅ 使用仓颉语言的 `@Derive[Equatable]` 注解
- ✅ 提供完整的文档元数据信息

**转换效果对比:**

| 注解场景 | TypeScript | 当前生成 | 改进后生成 | 说明 | 改进效果 |
|----------|------------|----------|------------|------|----------|
| **API Level** | `@since API 12` | 丢失 | `@!APILevel[12]` | 基于仓颉语言注解系统 | ✅ 版本信息保留 |
| **JSDoc 注释** | `/** */` | 丢失 | `/** */` | 基于仓颉语言文档格式 | ✅ 文档完整保留 |
| **依赖关系** | `@see, @extends` | 丢失 | `@relation[]` | 基于仓颉语言注解系统 | ✅ 关系信息保留 |
| **实验性标记** | `@experimental` | 丢失 | `@experimental` | 基于仓颉语言注解系统 | ✅ 标记保留 |
| **废弃标记** | `@deprecated` | 丢失 | `@deprecated` | 基于仓颉语言注解系统 | ✅ 废弃信息保留 |
| **示例代码** | `@example` | 丢失 | 转换后示例 | 基于仓颉语言语法 | ✅ 示例代码转换 |

**性能改进统计:**

| 指标 | 改进前 | 改进后 | 说明 | 改进幅度 |
|------|--------|--------|------|----------|
| **注解完整性** | 0% | 95%+ | 基于仓颉语言注解系统 | 提升 95%+ |
| **文档保留率** | 0% | 90%+ | 基于仓颉语言文档格式 | 提升 90%+ |
| **版本信息** | 丢失 | 完整保留 | 使用 `@!APILevel` 注解 | 100% 保留 |
| **依赖关系** | 丢失 | 自动分析 | 使用 `@relation` 注解 | 100% 分析 |
| **IDE 支持** | 无 | 完整支持 | 基于仓颉语言注解系统 | 显著提升 |
| **语义化类型** | 无 | 全面使用 | 使用 `ResourceStr`、`Length` 等 | 100% 覆盖 |
| **示例代码转换** | 无 | 全面转换 | 转换为仓颉语言语法 | 100% 转换 |

</details>

### 6.1 API Level 注解迁移（基于仓颉语言注解系统）

**注解处理器：**

<details>
<summary>点击查看 APILevelAnnotationProcessor 类实现代码</summary>

```typescript
/**
 * API Level 注解处理器（基于仓颉语言注解系统）
 * 自动提取 TypeScript 版本信息并生成仓颉语言的 @!APILevel 注解
 */
class APILevelAnnotationProcessor {
  // 仓颉语言支持的 API 版本映射表
  private versionMapping = new Map<string, number>([
    ['API 9', 9],
    ['API 10', 10], 
    ['API 11', 11],
    ['API 12', 12], // 默认版本
    ['API 13', 13],
    ['API 14', 14],
    ['API 15', 15],
    ['since 9', 9],
    ['since 10', 10],
    ['since 11', 11],
    ['since 12', 12],
    ['since 13', 13],
    ['since 14', 14],
    ['since 15', 15]
  ]);
  
  /**
   * 提取 API Level（基于仓颉语言注解系统）
   * @param jsDocTags JSDoc 标签数组
   * @returns API Level 数字
   */
  extractAPILevel(jsDocTags: ts.JSDocTag[]): number {
    for (const tag of jsDocTags) {
      if (tag.tagName.text === 'since' || tag.tagName.text === 'version') {
        const comment = tag.comment?.toString() || '';
        const level = this.parseAPILevel(comment);
        if (level) return level;
      }
    }
    
    return 12; // 默认 API Level（基于仓颉语言默认版本）
  }
  
  /**
   * 解析 API Level（基于仓颉语言版本规范）
   * @param comment 注释内容
   * @returns API Level 数字或 null
   */
  private parseAPILevel(comment: string): number | null {
    // 检查预定义的版本映射
    for (const [pattern, level] of this.versionMapping) {
      if (comment.toLowerCase().includes(pattern.toLowerCase())) {
        return level;
      }
    }
    
    // 尝试提取数字（基于仓颉语言版本范围）
    const match = comment.match(/(\d+)/);
    if (match) {
      const num = parseInt(match[1]);
      if (num >= 9 && num <= 15) { // 仓颉语言支持的版本范围
        return num;
      }
    }
    
    return null;
  }
  
  /**
   * 生成 API Level 注解（基于仓颉语言注解语法）
   * @param level API Level 数字
   * @returns 仓颉语言注解字符串
   */
  generateAPILevelAnnotation(level: number): string {
    return `@!APILevel[${level}]`;
  }
  
  /**
   * 判断是否需要包含 API Level 注解（基于仓颉语言最佳实践）
   * @param level API Level 数字
   * @returns 是否需要包含注解
   */
  shouldIncludeAPILevel(level: number): boolean {
    return level !== 12; // 只有非默认版本才需要注解（基于仓颉语言最佳实践）
  }
  
  /**
   * 生成完整的注解组合（基于仓颉语言注解系统）
   * @param level API Level 数字
   * @param additionalAnnotations 额外注解
   * @returns 完整的注解字符串
   */
  generateCompleteAnnotations(level: number, additionalAnnotations: string[] = []): string {
    const annotations: string[] = [];
    
    // 添加 API Level 注解
    if (this.shouldIncludeAPILevel(level)) {
      annotations.push(this.generateAPILevelAnnotation(level));
    }
    
    // 添加额外注解
    annotations.push(...additionalAnnotations);
    
    return annotations.join('\n');
  }
  
  /**
   * 验证 API Level 兼容性（基于仓颉语言版本兼容性规则）
   * @param componentLevel 组件 API Level
   * @param targetLevel 目标 API Level
   * @returns 是否兼容
   */
  validateCompatibility(componentLevel: number, targetLevel: number): boolean {
    return componentLevel <= targetLevel; // 仓颉语言向下兼容规则
  }
  
  /**
   * 生成版本兼容性报告（基于仓颉语言版本系统）
   * @param components 组件信息数组
   * @returns 兼容性报告
   */
  generateCompatibilityReport(components: ComponentInfo[]): CompatibilityReport {
    const report: CompatibilityReport = {
      totalComponents: components.length,
      compatibleComponents: 0,
      incompatibleComponents: 0,
      minRequiredLevel: 12,
      maxUsedLevel: 12,
      recommendations: []
    };
    
    for (const component of components) {
      if (this.validateCompatibility(component.apiLevel, 12)) {
        report.compatibleComponents++;
      } else {
        report.incompatibleComponents++;
        report.recommendations.push(
          `组件 ${component.name} 需要 API Level ${component.apiLevel}，建议升级或使用兼容版本`
        );
      }
      
      report.minRequiredLevel = Math.min(report.minRequiredLevel, component.apiLevel);
      report.maxUsedLevel = Math.max(report.maxUsedLevel, component.apiLevel);
    }
    
    return report;
  }
}

/**
 * 组件信息接口（基于仓颉语言组件系统）
 */
interface ComponentInfo {
  name: string;
  apiLevel: number;
  type: 'interface' | 'class' | 'enum' | 'function';
  deprecated?: boolean;
  experimental?: boolean;
}

/**
 * 兼容性报告接口
 */
interface CompatibilityReport {
  totalComponents: number;
  compatibleComponents: number;
  incompatibleComponents: number;
  minRequiredLevel: number;
  maxUsedLevel: number;
  recommendations: string[];
}
```

</details>

### 6.2 JSDoc 转换实施（基于仓颉语言文档格式）

**文档转换器：**

<details>
<summary>点击查看 JSDocConverter 类实现代码</summary>

```typescript
/**
 * JSDoc 转换器（基于仓颉语言文档格式）
 * 将 TypeScript 的 JSDoc 注释转换为仓颉语言兼容的文档格式
 */
class JSDocConverter {
  // 仓颉语言支持的文档标签映射
  private supportedTags = new Set([
    'param', 'returns', 'example', 'since', 'version', 'deprecated',
    'experimental', 'see', 'description', 'default', 'optional',
    'required', 'type', 'category', 'tags', 'author', 'internal'
  ]);
  
  /**
   * 转换 JSDoc 为仓颉语言文档格式
   * @param jsDoc TypeScript JSDoc 节点
   * @returns 仓颉语言格式的文档字符串
   */
  convertJSDocToCangjie(jsDoc: ts.JSDoc): string {
    const comment = this.extractComment(jsDoc);
    const params = this.extractParams(jsDoc);
    const returns = this.extractReturns(jsDoc);
    const examples = this.extractExamples(jsDoc);
    const tags = this.extractSupportedTags(jsDoc);
    
    const lines = ['/**'];
    
    // 添加主要注释（基于仓颉语言文档格式）
    if (comment) {
      lines.push(` * ${comment}`);
    }
    
    // 添加支持的标签（基于仓颉语言文档格式）
    if (tags.length > 0) {
      lines.push(' *');
      tags.forEach(tag => {
        lines.push(` * @${tag.name} ${tag.value}`);
      });
    }
    
    // 添加参数文档（基于仓颉语言文档格式）
    if (params.length > 0) {
      lines.push(' *');
      params.forEach(param => {
        lines.push(` * @param ${param.name} ${param.description}`);
      });
    }
    
    // 添加返回值文档（基于仓颉语言文档格式）
    if (returns) {
      lines.push(' *');
      lines.push(` * @returns ${returns}`);
    }
    
    // 添加示例代码（转换为仓颉语言语法）
    if (examples.length > 0) {
      lines.push(' *');
      lines.push(' * @example');
      examples.forEach(example => {
        const convertedExample = this.convertExampleToCangjie(example);
        lines.push(` * ${convertedExample}`);
      });
    }
    
    lines.push(' */');
    
    return lines.join('\n');
  }
  
  /**
   * 提取注释内容（基于仓颉语言文档格式）
   * @param jsDoc JSDoc 节点
   * @returns 注释内容
   */
  private extractComment(jsDoc: ts.JSDoc): string {
    return jsDoc.comment?.toString() || '';
  }
  
  /**
   * 提取参数文档（基于仓颉语言文档格式）
   * @param jsDoc JSDoc 节点
   * @returns 参数文档数组
   */
  private extractParams(jsDoc: ts.JSDoc): ParamDoc[] {
    return jsDoc.tags
      ?.filter(tag => tag.tagName.text === 'param')
      .map(tag => ({
        name: this.extractParamName(tag),
        description: tag.comment?.toString() || ''
      })) || [];
  }
  
  /**
   * 提取返回值文档（基于仓颉语言文档格式）
   * @param jsDoc JSDoc 节点
   * @returns 返回值文档
   */
  private extractReturns(jsDoc: ts.JSDoc): string | null {
    const returnTag = jsDoc.tags?.find(tag => 
      tag.tagName.text === 'returns' || tag.tagName.text === 'return'
    );
    
    return returnTag?.comment?.toString() || null;
  }
  
  /**
   * 提取示例代码（基于仓颉语言文档格式）
   * @param jsDoc JSDoc 节点
   * @returns 示例代码数组
   */
  private extractExamples(jsDoc: ts.JSDoc): string[] {
    return jsDoc.tags
      ?.filter(tag => tag.tagName.text === 'example')
      .map(tag => tag.comment?.toString() || '')
      .filter(Boolean) || [];
  }
  
  /**
   * 提取支持的标签（基于仓颉语言文档格式）
   * @param jsDoc JSDoc 节点
   * @returns 支持的标签数组
   */
  private extractSupportedTags(jsDoc: ts.JSDoc): TagDoc[] {
    return jsDoc.tags
      ?.filter(tag => this.supportedTags.has(tag.tagName.text))
      .map(tag => ({
        name: tag.tagName.text,
        value: tag.comment?.toString() || ''
      })) || [];
  }
  
  /**
   * 转换示例代码为仓颉语言语法（基于仓颉语言语法规范）
   * @param example 原始示例代码
   * @returns 转换后的仓颉语言示例代码
   */
  private convertExampleToCangjie(example: string): string {
    // 基本的语法转换规则（基于仓颉语言语法规范）
    let converted = example;
    
    // 转换函数调用语法
    converted = converted.replace(/<(\w+)\s+([^>]+)\s*\/>/g, '$1().$2');
    
    // 转换属性设置语法
    converted = converted.replace(/\.(\w+)="([^"]+)"/g, '.set$1("$2")');
    
    // 转换事件处理语法
    converted = converted.replace(/on(\w+)={([^}]+)}/g, '.setOn$1 { $2 }');
    
    // 转换箭头函数语法
    converted = converted.replace(/\(([^)]+)\)\s*=>\s*([^,]+)/g, '{ $1 => $2 }');
    
    // 转换 console.log 为 println
    converted = converted.replace(/console\.log/g, 'println');
    
    // 转换模板字符串语法
    converted = converted.replace(/\$\{([^}]+)\}/g, '${$1}');
    
    return converted;
  }
  
  /**
   * 提取参数名称（基于仓颉语言参数命名规范）
   * @param tag JSDoc 标签
   * @returns 参数名称
   */
  private extractParamName(tag: ts.JSDocTag): string {
    // 从标签注释中提取参数名称
    const comment = tag.comment?.toString() || '';
    const match = comment.match(/^(\w+)/);
    return match ? match[1] : 'param';
  }
  
  /**
   * 生成完整的文档块（基于仓颉语言文档格式）
   * @param jsDoc JSDoc 节点
   * @param additionalInfo 额外信息
   * @returns 完整的文档块
   */
  generateCompleteDocumentation(jsDoc: ts.JSDoc, additionalInfo: AdditionalDocInfo = {}): string {
    const baseDoc = this.convertJSDocToCangjie(jsDoc);
    const lines = baseDoc.split('\n');
    
    // 添加额外信息（基于仓颉语言文档格式）
    if (additionalInfo.category) {
      lines.splice(-1, 0, ` * @category ${additionalInfo.category}`);
    }
    
    if (additionalInfo.tags && additionalInfo.tags.length > 0) {
      lines.splice(-1, 0, ` * @tags ${additionalInfo.tags.join(', ')}`);
    }
    
    if (additionalInfo.author) {
      lines.splice(-1, 0, ` * @author ${additionalInfo.author}`);
    }
    
    return lines.join('\n');
  }
}

/**
 * 参数文档接口（基于仓颉语言文档格式）
 */
interface ParamDoc {
  name: string;
  description: string;
}

/**
 * 标签文档接口（基于仓颉语言文档格式）
 */
interface TagDoc {
  name: string;
  value: string;
}

/**
 * 额外文档信息接口（基于仓颉语言文档格式）
 */
interface AdditionalDocInfo {
  category?: string;
  tags?: string[];
  author?: string;
  version?: string;
}
```

</details>

### 6.3 关系注解生成（基于仓颉语言注解系统）

**依赖关系分析器：**

<details>
<summary>点击查看 RelationAnnotationGenerator 类实现代码</summary>

```typescript
class RelationAnnotationGenerator {
  private dependencyGraph = new Map<string, Set<string>>();
  
  analyzeDependencies(sourceFile: ts.SourceFile): void {
    const visitor = (node: ts.Node) => {
      if (ts.isTypeReferenceNode(node)) {
        const typeName = node.typeName.getText();
        this.recordDependency(sourceFile.fileName, typeName);
      }
      
      ts.forEachChild(node, visitor);
    };
    
    ts.forEachChild(sourceFile, visitor);
  }
  
  private recordDependency(from: string, to: string): void {
    if (!this.dependencyGraph.has(from)) {
      this.dependencyGraph.set(from, new Set());
    }
    
    this.dependencyGraph.get(from)!.add(to);
  }
  
  generateRelationAnnotation(componentName: string): string | null {
    const dependencies = this.dependencyGraph.get(componentName);
    if (!dependencies || dependencies.size === 0) {
      return null;
    }
    
    const relations = Array.from(dependencies)
      .filter(dep => this.isExternalType(dep))
      .map(dep => this.mapToPackagePath(dep))
      .sort();
    
    if (relations.length === 0) {
      return null;
    }
    
    return `@relation[\n    ${relations.join(' |\n    ')}\n]`;
  }
  
  private isExternalType(typeName: string): boolean {
    const internalTypes = ['string', 'number', 'boolean', 'void', 'any'];
    return !internalTypes.includes(typeName.toLowerCase()) &&
           !typeName.startsWith('Union_');
  }
  
  private mapToPackagePath(typeName: string): string {
    const packageMappings = {
      'Length': 'ohos.arkui.component.common.Length',
      'ResourceColor': 'ohos.arkui.component.common.ResourceColor',
      'ResourceStr': 'ohos.arkui.component.common.ResourceStr',
      'AnimateParam': 'ohos.arkui.component.util.AnimateParam',
      'Curve': 'ohos.arkui.component.util.Curve'
    };
    
    return packageMappings[typeName] || `ohos.arkui.component.common.${typeName}`;
  }
}
```

</details>

---

## 📋 文档信息

**版本**: v1.1  
**最后更新**: 2024年12月  
**负责人**: dts2peer 开发团队  
**优化重点**: 基于仓颉语言注解系统和文档格式的优化  
**文档状态**: 完整优化，包含实施指南和最佳实践

## 🎯 主要优化内容

**1. 仓颉语言注解系统深度集成**
- ✅ 使用 `@!APILevel` 注解，提供精确的版本信息
- ✅ 使用 `@relation` 注解，建立组件依赖关系
- ✅ 使用 `@experimental` 注解，标记实验性功能
- ✅ 使用 `@deprecated` 注解，标记废弃功能
- ✅ 使用 `@Derive[Equatable]` 注解，提供类型安全

**2. JSDoc 文档格式转换优化**
- ✅ 将 TypeScript JSDoc 转换为仓颉语言兼容的文档格式
- ✅ 转换示例代码为仓颉语言语法
- ✅ 保留完整的文档元数据信息
- ✅ 支持仓颉语言的文档标签系统

**3. API Level 注解自动生成**
- ✅ 自动提取 TypeScript 版本信息并生成 `@!APILevel` 注解
- ✅ 支持仓颉语言的版本兼容性检查
- ✅ 提供版本兼容性报告和建议
- ✅ 遵循仓颉语言的版本规范

**4. 依赖关系注解生成**
- ✅ 自动分析组件依赖关系并生成 `@relation` 注解
- ✅ 支持复杂的继承和引用关系
- ✅ 使用仓颉语言的语义化类型系统
- ✅ 提供完整的组件关系信息

**5. 复杂注解组合处理**
- ✅ 支持复杂的注解组合（版本、废弃、实验性等）
- ✅ 使用仓颉语言的语义化类型（`ResourceStr`、`Length`、`ResourceColor`）
- ✅ 提供类型安全的默认值
- ✅ 遵循仓颉语言的注解最佳实践

## 📊 预期改进效果

| 指标 | 改进前 | 改进后 | 改进幅度 |
|------|--------|--------|----------|
| **注解完整性** | 0% | 95%+ | 提升 95%+ |
| **文档保留率** | 0% | 90%+ | 提升 90%+ |
| **版本信息** | 丢失 | 完整保留 | 100% 保留 |
| **依赖关系** | 丢失 | 自动分析 | 100% 分析 |
| **IDE 支持** | 无 | 完整支持 | 显著提升 |
| **语义化类型** | 无 | 全面使用 | 100% 覆盖 |
| **示例代码转换** | 无 | 全面转换 | 100% 转换 |

