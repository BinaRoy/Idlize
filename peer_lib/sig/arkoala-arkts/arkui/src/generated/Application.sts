/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ComputableState, IncrementalNode, GlobalStateManager, StateManager, StateContext, MutableState, State, contextLocal, contextLocalScope, createAnimationTimer, memoRoot } from "@koalaui/runtime"
import { nativeModule } from "#components"
import { ArkoalaHost, ArkoalaControl, WaitFramesEvent, UIElement } from "./Declarations"
import { ArkoalaControlImpl } from "./ArkoalaControl"
import { SerializerBase } from "@arkoala/arkui/peers/SerializerBase"
import { createSerializer } from "@arkoala/arkui/peers/Serializer"
import { wrapCallback } from "./CallbackRegistry"
import { PeerNode } from "./PeerNode"
import { ArkUINodeType } from "./peers/ArkUINodeType"
import { KPointer, pointer } from "@koalaui/interop"
import { checkEvents } from "./Events"

const CURRENT_CONTROL = "ohos.arkoala.control"
export interface ApplicationEmulatedEvent {
    nodeId: int
    x: number
    y: number
    status: int
    text: string
}

class PartialUpdateRecord {
    public update: () => void
    public context: Object
    public callback: (before: boolean) => void

    constructor(update: () => void, context: Object, callback: (before: boolean) => void) {
        this.callback = callback
        this.context = context
        this.update = update
    }
}

let partialUpdates = new Array<PartialUpdateRecord>()
let _currentPartialUpdateContext: Object | undefined = undefined


/**
 * Provide partial update lambda and context.
 *
 * @param update - function that performs state update
 * @param context - context available to UI code when state update effect happens
 */
export function addPartialUpdate<T>(update: () => void, context: T, callback: (before: boolean) => void): void {
    partialUpdates.push(new PartialUpdateRecord(update, context as Object, callback))
}

/**
 * Current partial update context or undefined.
 *
 * @returns current partial update context
 */
export function currentPartialUpdateContext<T>(): T | undefined {
    return _currentPartialUpdateContext as (T | undefined)
}

function createMemoRoot(manager: StateManager): ComputableState<IncrementalNode> {
    const peer = new PeerNode(ArkUINodeType.Root, 0, "Root")
    const node = manager.updatableNode<IncrementalNode>(peer, (context: StateContext) => {
        const frozen = manager.frozen
        manager.frozen = true
        // call memoEntry
        manager.frozen = frozen
    })
    node.value
    return node
}

function updateStates(manager: StateManager, root: State<IncrementalNode>) {
    // Ensure all current state updates took effect.
    manager.updateSnapshot()
    root.value
    if (partialUpdates.length > 0) {
        // If there are pending partial updates - we apply them one by one and provide update context.
        for (let update of partialUpdates) {
            // Set the context available via currentPartialUpdateContext() to @memo code.
            _currentPartialUpdateContext = update.context
            // Update states.
            update.update()
            // Propagate changes.
            manager.updateSnapshot()
            // Notify subscriber.
            update.callback(true)
            // Compute new tree state
            try {
                root.value
            } catch (error) {
                console.log('has error in partialUpdates')
            }
            // Notify subscriber.
            update.callback(false)
            // Clear context.
            _currentPartialUpdateContext = undefined
        }
        // Clear partial updates list.
        partialUpdates.splice(0, partialUpdates.length)
    }
}

function measureLayoutAndDraw(peerNode: PeerNode) {
    nativeModule()._MeasureLayoutAndDraw(peerNode.peer.ptr)
}

function dumpTree(node: IncrementalNode, indent: int = 0) {
    const indentToString = (indent: number) => {
        let str = ""
        for (let i = 0; i <= indent; i++) str += " "
        return str
    }

    if (indent == 0) console.log("> Dump tree:")

    let child = node.firstChild
    console.log("> " + indentToString(indent++) + "| " + node)

    while (child) {
        dumpTree(child!, indent + 1)
        child = child!.nextSibling
    }
}

let crashDumped = false
function drawCurrentCrash(crash: Object) {
    let msg = crash.toString() + "\n"
    if (Object.hasOwn(crash, "stack")) msg += (crash as Error).stack
    if (!crashDumped) {
        console.log(msg)
        crashDumped = true
    }
    nativeModule()._ShowCrash(msg ?? "unknown error message")
}

export class Application {
    private manager: StateManager | undefined = undefined
    private root: ComputableState<IncrementalNode> | undefined = undefined
    private currentCrash: Object | undefined = undefined
    private enableDumpTree = false

    constructor() {
    }

    private start(): Application {
        this.manager = GlobalStateManager.instance
        this.root = createMemoRoot(this.manager!)
        return this
    }

    private checkEvents(what: int) {
        checkEvents()
    }

    private updateState() {
        console.log("ARKTS: updateState")
        updateStates(this.manager!, this.root!)
        // Here we request to draw a frame and call custom components JS callbacks.
        measureLayoutAndDraw(this.root!.value as PeerNode)
    }
    
    private render() {
        console.log("ARKTS: render2")
        // Call callbacks.
        this.manager?.callCallbacks()
    }

    enter(arg0: int, arg1: int) {
        if (this.currentCrash) {
            drawCurrentCrash(this.currentCrash!)
        } else {
            try {
                this.loopIteration(arg0, arg1)
                if (this.enableDumpTree) dumpTree(this.root!.value)
            } catch (error) {
                this.currentCrash = error as Object
            }
        }
    }

    loopIteration(arg0: int, arg1: int) {
        this.checkEvents(arg0)
        this.updateState()
        this.render()
    }

    static startApplication(): Application {
        return new Application().start()
    }
}
